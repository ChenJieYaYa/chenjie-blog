# Redis概述

## 一、Redis简单介绍

### 1.Redis是什么?

Redis是高性能、K-V、**非关系型**、**缓存**数据库，C语言编写

* 基于内存、同时支持缓存

Redis的操作是**原子操作**

### 2.Redis的版本介绍

* 版本号第二位为**奇数**是**非稳定版**

- 版本号第二位为**偶数**是**稳定版**

### 3.Redis支持的数据类型及特性

**String**：支持字符串、整性、浮点型、二进制操作，可自增自减

* 适用于存共享Session、分布式锁、计数器、限流

**List**：列表，可模拟堆栈等数据结构

* 适用于存粉丝列表、点赞列表、评论列表

**Set**：无序且唯一

* 适用于存用户标签、随机抽奖等去重场景

**ZSet**：有序且唯一

* 适用于存排行榜、寻找Top

**Hash**：K-V

* 适用于存用户信息

### 4.Redis应用场景

#### 4.1.缓存

合理的利用缓存，比如缓存热点数据，不仅可以提升网站的访问速度，还可以降低数据库DB的压力
并且Redis提供持久化机制与多种数据结构，强的一批

#### 4.2.排行榜

Redis提供**ZSset**数据类型能实现复杂的排行榜，比如用户每天上传视频，获得点赞的排行榜可以这样设计

> 用户Jay上传一个视频获得6个赞：`zadd user:ranking:2021-03-03 Jay 6`
> 过了一段时间再获得一个赞：`zincrby user:ranking:2021-03-03 Jay 1`
> 如果某个用户John作弊，需要删除该用户：`zrem user:ranking:2021-03-03 John`
> 展示获取赞数最多的3个用户：`zrevrangebyrank user:ranking:2021-03-03 0 2`

#### 4.3.计数器

短视频的播放数、电商网站的浏览数都要用到计数器，这些数据一般要求都是**实时的**，如果并发量很大对于传统关系型数据的性能是一种挑战，Redis天然支持计数功能而且计数的性能也非常好，可以说是计数器系统的重要选择

#### 4.4.共享Session

分布式Web服务将用户的Session信息保存在各自服务器，用户刷新一次可能就需要重新登录，Redis将用户的Session进行集中管理，每次用户更新或者查询登录信息都直接从Redis中集中获取

#### 4.5.分布式锁

分布式服务下遇到对同一个资源的并发访问的技术难题，如秒杀、下单减库存等场景，用synchronize或者reentrantlock本地锁肯定是不行，并发量不大话使用数据库的悲观锁、乐观锁来实现没啥问题，但是在高并发场合中，利用数据库锁来控制资源的并发访问，会影响数据库的性能，实际上，可以用**Redis的setnx实现分布式锁**

#### 4.6.社交网络

赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型数据不太适保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能

#### 4.7.消息队列

消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，**主要用于业务解耦、流量削峰及异步处理实时性低的业务**，Redis提供发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统

#### 4.8.位操作

用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等，腾讯10亿用户，要几个毫秒内查询到某个用户是否在线，能怎么做？千万别说给每个用户建立一个Key，然后挨个记，可以**使用setbit、getbit、bitcount命令**，**原理是Redis内构建足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示用户id(必须是数字)，，显然这个几亿长的大数组就能通过下标和元素值(0和1)来构建一个记忆系统**

## 二、Redis为什么快？

### 1.基于内存

Redis基于内存，目的是**减少磁盘IO**

### 2.单线程

Redis基于内存，所以CPU并不是Redis的性能瓶颈，**内存大小和网络IO(网络带宽)**才是，且单线程容易实现，所以采取单线程，有效避免多线程下加锁带来的开销与系列问题，如死锁、上下文切换等

Redis6.0后采取多线程，但也不是完全摒弃单线程，处理客户端读写与协议解析通过多线程处理，执行客户端命令还是单线程，使用多线程可以提升IO读写效率

### 3.IO多路复用

多路指多个Client连接Redis，复用指单线程处理请求，**有效提高系统吞吐量**

多路复用主要有select、poll、epoll等三种技术，过程大概是将Client请求放入队列中，Redis循环从队列中取出请求处理

### 4.虚拟内存

将冷数据存于磁盘，为热数据腾出更多空间，通过虚拟内存可实现**冷热数据分离**，避免因内存不足而造成访问速度下降

### 5.高效的数据结构

Redis支持的各种数据类型的底层数据结构如下图

![1657452978786](assets/1657452978786.png)

**动态字符串**内部存储使用SDS封装，SDS结构如下图

![1657453124090](assets/1657453124090.png)

**字典**实际就是哈希表，通过Key快速找到Value，时间复杂度O(1)

**跳跃表**实际就是在链表基础上多加几级索引，提升查找效率

![1657453306172](assets/1657453306172.png)

### 6.合适的数据编码

**String**：数字用int，非数字小于等于39字节字符串使用embstr，大于39个字节使用raw

**List**：列表元素个数小于512，且列表每个元素的值都小于64字节(默认)，使用ziplist编码，否则使用linkedlist编码

**Hash**：哈希类型元素个数小于512个，且每个值小于64字节，使用ziplist编码，否则使用hashtable编码

**Set**：集合元素都是整数,且元素个数小于512个，使用intset编码，否则使用hashtable编码

**ZSet**：有序集合的元素个数小于128，且每个元素的值小于64字节，使用ziplist编码，否则使用skiplist

## 三、缓存穿透、缓存雪崩、缓存击穿

### 1.缓存穿透

常见缓存方式是当请求发来时，先经过缓存，在缓存中查，当缓存未命中则去数据库查，数据库有则将值更新到缓存后再返回

缓存穿透指查不存在的值时，每次都需要查数据库，给数据库带来压力，即**请求穿透到数据库**

缓存穿透一般发生于业务设计不合理、运维或开发人员事务、黑客恶意攻击等场景

缓存穿透可直接在API处对参数进行校验，过滤非法请求的方式避免，也可通过**布隆过滤器**避免

### 2.缓存雪崩

缓存雪崩指大量数据到达过期时间，且查询量巨大，给数据库带来压力

缓存雪崩可通过均匀设置过期时间，使过期时间相对离散有效解决，如较大固定值+较小的随机值(5h+0-1800s)，Redis宕机使整个Redis不可用也会导致缓存雪崩，可通过构造Redis高可用集群解决

### 3.缓存击穿

缓存击穿指热点Key到达过期时间，恰好此时对该热点Key发来大量请求，给数据库带来压力

缓存击穿可通过互斥锁或永不过期(异步更新过期时间)解决

## 四、布隆过滤器

### 1.什么是布隆过滤器？

布隆过滤器是一种占极小空间的数据结构，由一个超长二进制数组和多个Hash函数组成，用于检索数据是否存在，其占空间小且查询时间短，但存在误识别的情况(Hash冲突)且删除困难

### 2.布隆过滤器的原理

假设集合A中有n个元素，利用k个哈希散列函数，将A中的每个元素映射到一个长度为a位的数组B中的不同位置上，这些位置上的二进制数均设置为1

如果待检查的元素经过这k个哈希散列函数的映射后，发现其k个位置上的二进制数全部为1，这个元素很可能属于集合A，反之一定不属于集合A

### 3.布隆过滤器的实现过程

假设集合A有3个元素，分别为{d1,d2,d3}，有1个哈希函数为Hash1，现在将A的每个元素映射到长度为16位数组B

![1657455769690](assets/1657455769690.png)

映射d1，假设Hash1(d1)= 2，则数组B中下标为2的格子改成1

![1657455790055](assets/1657455790055.png)

映射d2，假设Hash1(d2)= 5，则数组B中下标为5的格子改成1

![1657455808299](assets/1657455808299.png)

映射d3，假设Hash1(d3)= 2，则也将数组B中下标为2的格子改成1

![1657455835977](assets/1657455835977.png)

确认元素dn是否在集合A里，只要算出Hash1(dn)得到索引，索引对应元素是0则该元素不在集合A，如果索引下标是1也只能表示该元素**可能**是A中的某一个元素，因为d1和d3得到的下标值都可能是1，所以布隆过滤器是存在Hash碰撞导致假阳性，判断存在误差的缺点

如何减少这种误差？**多搞几个哈希函数映射**，降低哈希碰撞的概率；同时**增加二进制数组的bit长度**，可以增大Hash函数生成的数据的范围，也可以降低哈希碰撞的概率

又增加一个Hash2哈希映射函数，假设Hash2(d1)=6，Hash2(d3)=8，使d1和d3不冲突

![1657455996049](assets/1657455996049.png)

布隆过滤器并没有存放完整的数据，只是运用一系列哈希映射函数计算出位置，然后填充二进制向量，**如果数量很大的话，布隆过滤器通过极少的错误率，换取了存储空间的极大节省**

## 五、热点Key问题

### 1.什么是热点Key？

热点Key顾名思义是访问频率高的Key

若热点Key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务

热点Key产生于秒杀，热点新闻等场景，或者请求分片集中，超过单台Redis服务器的性能

### 2.如何解决热点Key问题？

热点Key可通过**将热点Key副本分布于Redis集群，然后负载均衡请求**解决，也可通过**将热点Key本身分布于Redis集群**解决

## 六、Redis过期键删除策略

### 1.删除策略有哪些？

**定时删除**：设置键过期时间

**惰性删除**：放任键过期不管，每次查键时，先检查键是否过期，若过期则删除该键，若未过期则取出该键

**定期删除**：每隔一段时间检查键是否过期，删除过期的键

### 2.Redis采取哪些删除策略？

Redis采取**定期删除策略**，每隔一段时间随机抽取一定数量的Key检查是否过期，由于Key是随机抽取的，可能导致最后还是有大量过期Key没有删除，所以Redis同时采取**惰性删除策略**，每次取键前都检查键是否过期，但这样仍然可能存在过期键没有删除干净的情况，过期键一直不删除则一直存于内存中，随着业务量加大，可能导致内存爆满，此时Redis当然不会放任这些过期键不管，采用**内存淘汰策略**淘汰遗留下来的过期键

> Redis的定期删除策略为什么选择抽取部分Key检查是否过期，而不是所有？
>
> 若Redis中存储30万个键，每隔一段时间就要遍历每30万个键检查是否过期，导致CPU负载则别高，最后可能会宕机

### 3.Redis的内存淘汰机制有哪几种？

allkeys-lru：当内存不足以容纳新写入的数据时，从**所有的键中采取最近最少使用算法**淘汰

volatile-lru：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中采取最近最少使用算法**淘汰

allkeys-lfu：当内存不足以容纳新写入的数据时，从**所有的键中采取最不经常使用算法**淘汰

volatile-lfu：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中采取最不经常使用算法**淘汰

> lru是淘汰**最长时间**没有使用的，lfu是淘汰一段时间内**使用次数**最少的

allkeys-random：当内存不足以容纳新写入的数据时，从**所有的键中随机**淘汰

volatile-random：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中随机**淘汰

allkeys-ttl：当内存不足以容纳新写入的数据时，从**所有的键中采取最接近过期时间算法**淘汰

nativation：当内存不足以容纳新写入的数据时，新写入操作会**报错**

## 七、Redis的持久化机制

### 1.持久化加载流程

**Redis基于内存，为了避免数据丢失则将数据保存到磁盘**

![1657625007688](assets/1657625007688.png)

### 2.RDB

**RDB指每隔一段时间将内存中的数据以快照的形式存于硬盘(dump.rdb)**，由于RDB操作有时间间隔，可能存在数据丢失的情况，数据安全性低，无法做到秒级持久化

RDB的触发机制有三种，save(阻塞式)、bgsave(异步式)、save m n(m秒内数据集存在N次修改触发bgsave)

> Redis生成RDB期间还可以处理读写请求吗？
>
> save触发RDB是阻塞式的，主线程运行处理Redis读写请求，bgsave触发RDB是异步式的，使用子进程生成RDB，父进程处理Redis读写请求

### 3.AOF

**AOF指将每次的写命令记录到单独的日志文件中**，每次重启Redis时会重新使用持久化日志文件恢复数据，随着时间的推移启动会越来越慢，默认关闭，AOF的工作流程如下图

![1657626392685](assets/1657626392685.png)

通过append的方式向AOF缓冲器写写命令，这样即使Redis中途宕机也可通过redis-check-aof工具保证数据的一致性

## 八、Redis高可用

### 1.配置高可用的目的

**高可用可防止单点故障，避免整个集群不可用**

### 2.Redis实现高可用的三种部署模式

#### 2.1.主从模式

主节点负责**读写操作**，从节点只负责**读操作**，且从节点的数据都来自主节点，实现原理叫**主从复制**，主从复制包括**全量复制和增量复制**

当Slave第一次启动连接Master会认为是第一次连接，采用全量复制

![1657718636345](assets/1657718636345.png)

slave与master全量同步之后，master上的数据如果再次发生更新，就会触发增量复制

![1657967577559](assets/1657967577559.png)

#### 2.2.哨兵模式

主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，显然多数业务场景都不能接受这种故障处理方式，Redis从2.8开始正式提供了Redis Sentinel(哨兵)架构来解决这个问题

哨兵模式是**由一个或多个(防止单点故障)Sentinel实例组成的Sentinel系统**，可以**监视所有的Redis主节点和从节点，以及各个哨兵之间还会相互监控**，并在**被监视的主节点进入下线状态时自动将下线主服务器属下的某个从节点升级为新的主节点，通过发布订阅的方式通知其他节点修改配置，切换主节点**，同时还可以**发送命令，等待Redis服务器(主从服务器)返回其监控的运行状态**

![1657968115336](assets/1657968115336.png)

哨兵的工作模式是这样的，每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送**PING命令**，如果实例距离最后一次有效回复PING命令的时间超过down-after-milliseconds选项所指定的值，则这个实例会被Sentinel标记为**主观下线**，如果一个Master被标记为主观下线，则**正在监视这个Master的所有Sentinel要以每秒一次的频率确认Master的确进入了主观下线状态**，当有足够数量的Sentinel(大于等于配置文件指定的值)在指定的时间范围内确认Master的确进入了主观下线状态，则Master会被标记为**客观下线**，一般情况下，每个Sentinel会以每10秒一次的频率向它已知的所有Master，Slave发送**INFO命令**，当Master被Sentinel标记为客观下线时，Sentinel向**下线的Master的所有Slave发送INFO命令的频率会从10秒一次改为每秒一次**，若没有足够数量的Sentinel同意Master已经下线，Master的客观下线状态就会被移除；若Master重新向Sentinel的PING命令返回有效回复，Master 的主观下线状态就会被移除

#### 2.3.Cluster集群模式

哨兵模式基于主从模式，实现读写分离，还可以自动切换，系统可用性更高，但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容，因此Cluster集群应运而生，它在Redis3.0加入的

**Cluster集群实现Redis的分布式存储，对数据进行分片**，也就是说每台Redis节点上存储不同的内容，来解决在线扩容的问题，并且它也提供复制和故障转移的功能

Redis Cluster集群通过**Gossip协议**进行通信，节点之间不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等，常用的Gossip消息分别是**ping、pong、meet、fail**

* **ping**：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点**是否在线和交换彼此状态信息**
* **meet**：**通知新节点加入**，消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换
* **pong**：当接收到ping、meet消息时，作为**响应消息回复给发送方确认消息正常通信**；pong消息内部**封装自身状态数据**，节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新
* **fail**：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点**更新为下线状态**

既然是分布式存储，Cluster集群使用的分布式算法是一致性Hash嘛？并不是，而是**Hash Slot插槽算法**

插槽算法把整个数据库被分为**16384个Slot(槽)**，每个进入Redis的键值对根据key进行散列，分配到这16384插槽中的一个，使用的哈希映射也比较简单，用CRC16算法计算出一个16位的值，再对16384取模，**数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽，集群中的每个节点负责一部分的Hash槽**，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：

```
节点A负责0~5460号哈希槽
节点B负责5461~10922号哈希槽
节点C负责10923~16383号哈希槽
```

Redis Cluster集群中，需要确保16384个槽对应的node都正常工作，如果某个node出现故障，它负责的Slot也会失效，整个集群将不能工作，**为了保证高可用，Cluster集群引入了主从复制**，一个主节点对应一个或者多个从节点，当其它主节点ping一个主节点A时，如果半数以上的主节点与 A通信超时，那么认为主节点A宕机，如果主节点宕机时，就会启用从节点

Redis的每一个节点上都有两个玩意，一个是插槽Slot(0~16383)，另外一个是Cluster，可以理解为一个集群管理的插件，当我们存取的key到达时，Redis会根据Hash Slot插槽算法取到编号在0~16383之间的哈希槽，通过这个值去找到对应的插槽所对应的节点，然后**直接自动跳转到这个对应的节点上进行存取操作**

### 3.实现高可用后的故障转移问题

**主观下线**： 某个节点认为另一个节点不可用，即下线状态，这个状态**并不是最终的故障判定**，只能代表一个节点的意见，可能存在误判情况

![1657969853667](assets/1657969853667.png)

**客观下线**： 标记一个节点**真正的下线**，集群内多个节点都认为该节点不可用，从而达成共识的结果，如果是持有槽的主节点故障，需要为该节点进行故障转移

![1657969882282](assets/1657969882282.png)

**故障恢复**：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用

![1657969912896](assets/1657969912896.png)

## 九、MySQL与Redis如何保证双写一致性

### 1.延时双删

**更新数据库后延迟休眠一会再删除缓存**，这种方案还可以，**只有休眠那一会可能有脏数据**，一般业务也会接受的，但是如果第二次删除缓存失败呢？缓存和数据库的数据还是可能不一致，给Key设置一个自然的expire过期时间，让它自动过期怎样？业务在该过期时间内接受的数据的不一致怎么办？还是有其他更佳方案

![1657970021167](assets/1657970021167.png)

### 2.删除缓存重试机制

延时双删可能会存在第二步的删除缓存失败，导致的数据不一致问题，删除失败就**多删除几次**呀，保证删除缓存成功就可以了呀，所以可以引入**删除缓存重试机制**

![1657970213908](assets/1657970213908.png)

### 3.读取biglog异步删除缓存

重试删除缓存机制会造成好多业务代码入侵，所以引入读取biglog异步删除缓存

![1657970429126](assets/1657970429126.png)





