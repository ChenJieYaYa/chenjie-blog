# 正则表达式

## 一、正则表达式是什么？

正则表达式是一种**描述文本规则的代码**，用于校验字符串是否满足规则，用于在一段文本中查找满足要求的内容等

## 二、规则

### 1.字符类

字符类中只能匹配一个字符

- `[abc]`：只能是`a`、`b`、`c`中的一个字符
- `[^abc]`：除了`a`、`b`、`c`之外的任何一个字符
- `[a-zA-Z]`：`a`到`z`或`A`到`Z`中的任何一个字符
- `[a-zA]`：`a`到`z`或`A`中的任何一个字符
- `[a-z&&[abc]]`：`&&`表示取两者的交集，结果是`[abc]`

例如`num[1-4s]`的结果可能是`num1`、`num2`、`num3`、`num4`、`nums`

### 2.预定义字符

- `\d`：数字`[0-9]`
- `\D`：非数字`[^0-9]`
- `\w`：英文、数字或下划线`[a-zA-Z_0-9] `
- `\W`：非英文、数字或下划线`[^\w] `
- `\s`：空白字符`[\t\n\x0B\f\r] `
- `\S`：非空白字符`[^\s]`

### 3.量词

字符类+量词表示同一个字符出现的次数

- `?`：0次或1次，非贪婪匹配
- `*`：0次或多次
- `+`：1次或多次
- `{n}`：n次
- `{n,}`：至少n次
- `{n,m}`：n到m次

### 4.贪婪&非贪婪匹配

贪婪匹配指尽可能多的获取数据，**默认就是贪婪匹配**，例如`abbbbbbbbbbbbcccc`使用正则`ab+`会匹配到`abbbbbbbbbbbb`

非贪婪匹配也就是尽可能少的获取数据，想要**非贪婪匹配只需在量词后加上`?`即可**，例如`abbbbbbbbbbbbcccc`使用正则`ab+?`会匹配到`ab`

### 5.元字符&特殊字符

元字符表示需要转义的字符，包括`(`、`)`、`[`、`]`、`{`、`}`、`\`、`^`、`$`、`|`、`?`、`*`、`+`、`.`

特殊字符有其特殊的含义，包括`\t`、`\n`、`\r`、`\f`、`\a`、`\e`、`\b`、`\v`、`\0`

### 6.捕获&非捕获分组

#### 6.1.分组

`[]`内部只能选取一个字符，而分组后表示选择字符串，**使用`()`表示分组**，分组后的内容看成整体

分组内部**使用`|`表示候选**，也就是或的意思，例如`(aaa|bbb|ccc)`表示`aaa`或`bbb`或`ccc`的一种，注意区分`[abc]`表示`a`或`b`或`c`的一个

分组分为捕获分组与非捕获分组

#### 6.2.捕获分组

**捕获分组**表示分组且保存数据，后续可通过特定的格式使用分组后的数据，使用分组的格式如下

- 正则内部使用：`\\组号`
- 正则外部使用：`$组号`

组号以左括号为基准，最左边的是第一组，其次第二组

请看一下例题，编写正则表达式

```java
//匹配出"我要学编程"，对重复的内容去重
String reg = "我要要要学学学学编编编编编编编编程程程程程程程";

//分析
//1.任意字符	.
//2.这个字符至少出现一次	.+
//3.为了满足条件，使用到replaceAll(参数1,参数2)
//4.参数2依赖与参数1，所以需要分组	(.)\\1+
reg.replaceAll("(.)\\1+","$1");
```

#### 6.3.非捕获分组

**非捕获分组**的括号并不表示分组，并不保存数据，使用捕获分组的方式获取不到数据，存在以下几种方式

- `?:`：`(?:8|9|10)`表示非捕获分组，若去掉`?:`则表示捕获分组
- `?=`：后面一定出现的部分，`Java(?=8|11|17)`表示`Java`后一定出现`8`、`11`、`17`
- `?!`：后面一定不出现的部分，`Java(?!8|11|17)`表示`Java`后一定不出现`8`、`11`、`17`

### 7.边界

`^`：行开头，在`[]`中表示取反

`$`：行结尾

`\b`：单词边界

`\B`：非单词边界

## 三、使用

### 1.String

String中存在方法`matches()`，通过`"待匹配字符串".matches(正则表达式)`的方式

其中`split()`和`replaceAll()`中也可以使用正则，表示切割和替换匹配正则的字符内容

### 2.Pattren&Matcher

Pattren表示模式对象，Matcher表示匹配器，使用方式如下

```java
Pattren p = Pattren.compile("Java\\d{0,2}");//正则表达式
Matcher m = p.matcher("Java哈哈哈哈哈Java16嘻嘻嘻嘻嘻嘻嘻Java18");//待匹配字符串

//字符串是否匹配正则表达式，匹配则返回true
boolean b1 = m.matches();//false

//从头开始是否存在匹配正则的子串，若有则返回true，同时记录子串的起始索引、结束索引+1，再次调用时继续向后匹配
boolean b2 = m.find();//true

//获取匹配到的子串，底层使用find方法中记录下来的索引截取，类似于substring()
String s1 = m.group();//Java
    
boolean b2 = m.find();//true
String s1 = m.group();//Java16
    
//使用循环改进
while(m.find()){
    System.out.println(m.group());
}
```

## 四、常见正则表达式

手机号：`1[3-9][0-9]{9}`或`1[3-9]\\d{9}`

座机号：座机号组成为`区号-号码`，`0\\d{2,3}-?[1-9]\\d{4,9}`

> 更多请参考[常见正则表达式](https://blog.csdn.net/weixin_51699336/article/details/121870554)





