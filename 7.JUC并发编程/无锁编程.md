# 无锁编程

## 一、问题引入

为什么会出现CAS呢？当然是出现问题解决问题了

`synchronized`是阻塞式锁，存在大量问题，如阻塞式锁导致CPU唤醒操作加大开销；不存在锁中断机制；若拿到锁的线程一直不释放锁怎么解决？即没有锁超时机制；非公平锁造成大量的资源竞争，同时还有可能造成死锁等其他安全问题，所以后来出现了`volatile`

`volatile`可以保证可见性与有序性，但不保证原子性，有所提升，但还不够，技术更新换代啊！这就是你掉头发的原因啦🤫

为了更进一步提升性能，出现CAS无锁编程，CAS实际是一种乐观锁

## 二、CAS概述

### 1.什么是CAS？

CAS全称Compare And Swap，基于乐观锁思想实现无锁编程



> 乐观锁：就是勇敢牛牛不怕困难的思想，即其他线程要修改共享变量我不怕不怕啦，就算共享变量被改也没关系，自己多重试几次，直到成功为止，不懂就看接下来CAS的原理
>
> 悲观锁：就是自私思想，如果共享变量到了我手里其他线程就休想碰她，他现在是我的女人(bushi哈哈)，等我用完了再解开，你们才有机会，咦，这个例子怎么优点渣男的味道哈哈，不管了



CAS 的特点
结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。

CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思

因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响







1.概述

线程安全的操作类





其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证比较-交换的原子性。
在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的



volatile
获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。
它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。
注意

volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）

CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果

为什么无锁效率高

无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大
但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。




