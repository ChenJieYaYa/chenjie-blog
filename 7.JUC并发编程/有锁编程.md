# 有锁编程

## 一、共享带来的问题

两个线程对初始值为0的静态变量，一个做自增，一个做自减，结果是0吗？

```java
static int i = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		i++;
	}, "t1");
    
	Thread t2 = new Thread(() -> {
		i--;
	}, "t2");
    
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	System.out.println(i);
}
```

结果正数、负数、零都有，为什么呢？接下来从字节码开始步步深入🙃

对于`i++`而言，实际会产生如下的JVM字节码指令，`i--`也类似，可看到分成四步

```java
getstatic i	//获取静态变量i的值
iconst_1	//准备常量1
iadd		//自增，i--改成 isub
putstatic i //将修改后的值存入静态变量i
```

通过上一张图解可知，完成静态变量自增和自减需要在主内存与线程工作内存间进行数据交换

![1658372661291](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658372661291.png)

对于单线程，以上自增和自减的8条字节码指令顺序执行，不会存在什么问题，但对多线程来说这8条指令可能交错运行，即线程1可能运行到第三条指令就切换上下文给线程2，线程2若顺利的运行完则将结果-1写回主存，此时继续执行线程1的第三天指令则将结果1写回主存，最终主存中i的结果为1，当然这8条字节码指令间还存在各种交替方式，所以最终i的值可能为正数、负数或零

**其实程序运行多线程本身是不存在问题的，问题出现在多线程访问共享资源，或者说多线程访问共享资源也没问题，问题出现在多线程对共享变量读写操作时发生指令交错**，出现了问题当然就要解决，请接着往下看<span style="color:green">大标题[二]就是解决方案</span>

对共享资源多线程读写操作的代码块称为**临界区**，多线程在临界区内运行，由于字节码指令执行顺序不同而导致结果无法预测称为发生**竞态条件**

```java
static int i = 0;
static void increment()
//临界区
{	i++;	}
static void decrement()
//临界区
{	i--;	}
```

## 二、synchronized

### 1.什么是synchronized？

`synchronized`又称对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程想要获取对象锁时会被阻塞

`synchronized`用于解决多线程操作同一资源时数据不一致问题，即**资源争抢问题**，保证持有锁的线程可以安全的执行临界区的代码，不用担心指令交替运行，解决并发编程三大特性之**原子性**

![1658300586029](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658300586029.png)

![1658300599862](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658300599862.png)

### 2.synchronized可重入证明

可重入表示自己可以第二次获得锁，若不可重入那么自己第二次获取锁时也将被锁住

```java
public class Re_synchronized {
    public synchronized void method1() {
        //main线程获取锁
        System.out.println("11111");
        method2();//若是非可重入，由于method1有锁，再去method2也需要锁，方法会阻塞在此
    }

    public synchronized void method2() {
        //main线程获取锁
        System.out.println("22222");
    }

    public static void main(String[] args) {
        Re_synchronized re = new Re_synchronized();
        re.method1();
    }
}
```

### 3.synchronized解决共享带来的问题

#### 3.1.synchronized代码块

语法格式如下

```java
synchronized(对象)//线程1，线程2(blocked)
{
	临界区
}
```

解决问题的代码如下

```java
static int i = 0;
static final Object room = new Object();

public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		synchronized (room) {
            i++;
        }
	}, "t1");
    
	Thread t2 = new Thread(() -> {
		synchronized (room) {
            i--;
        }
	}, "t2");
    
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	System.out.println(i);
}
```

以上代码如何理解呢？请继续往下康

`synchronized(对象)`中的对象相当于一个房间`room`，该房间只有唯一的入口，每次只能有一人进入，线程t1、t2想象成两个人，当线程t1执行`synchronized(room)`，相当于t1到达房间就把房门锁上，并拿走了钥匙，在房间内执行`i++`，若此时t2执行`synchronized(room)`，但发现房门被锁住，就只能在门外等，发生阻塞，恰好此时线程t1的CPU时间片用完，即使用房间的时间用完，那么t1将被提出门外，注意**t1被提出门外时还是带着钥匙的，而且房间门也没开**，所以t2还是在门外等，等待CPU再次轮询到t1时，他带着钥匙光荣回归，t1再次占用房间，当t1执行完`synchronized{}`内的任务才会开门出来，唤醒并把锁交给t2，这是t2才可以进入房间，继续关门...

Java是面向对象的语言，所以面向对象改进

```java
class Room {
	int value = 0;
    
	public void increment() {
		synchronized (this) {
			value++;
        }
	}
    public void decrement() {
        synchronized (this) {
            value--;
        }
    }
    public int get() {
        synchronized (this) {
            return value;
        }
    }
}

public class Test1 {
	public static void main(String[] args) throws InterruptedException {
		Room room = new Room();
        
		Thread t1 = new Thread(() -> {
			room.increment();
		}, "t1");
        
		Thread t2 = new Thread(() -> {
			room.decrement();
		}, "t2");
        
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(room.get());
	}
}
```

以上通俗的表达相信你已经理解了`synchronized(){}`的工作原理，**实际`synchronized`使用对象锁保证临界区代码的原子性，使临界区的操作不可分割**，继续请思考以下几个问题🤯，为了方便测试修改测试代码如下

①在`i++`和`i--`外加一层`for`循环，再把`synchronized(obj)`放在`for`循环的外面如何理解？**原子性**

②如果`t1 synchronized(obj1)`而`t2 synchronized(obj2)`会怎样运作？**锁对象**

```java
//若t1先执行，进入obj1房间，关门取锁
//t1中途被踢出房间，t2开始执行，但t2进入的是obj2房间，同样关门取锁
//若t2顺利运行完，则会再次切回t1，即结果临界区内代码无法保证原子性
public class Test02 {
    static final Object room1 = new Object();
    static final Object room2 = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            synchronized (room1) {
                System.out.println(Thread.currentThread().getName() + "开始运行");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "运行结束");

            }
        }, "t1");

        Thread t2 = new Thread(() -> {
            synchronized (room2) {
                System.out.println(Thread.currentThread().getName() + "开始运行");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "运行结束");
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t2运行结束
t1运行结束
```

③如果`t1 synchronized(obj)`而`t2`没有加会怎么样？如何理解？**锁对象**

```java
//若t1先执行，进入obj1房间，关门取锁
//t1中途被踢出房间，t2开始执行，但t2不存在房间的概念，所以它运行它的
//若它中途CPU时间片用完，那么t1会带锁回归到obj1，假设此时t1完毕，接着切回t2直到结束，所以还是无法保证原子性
public class Test03 {
    static final Object room1 = new Object();
    static final Object room2 = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {//加锁
            synchronized (room1) {
                System.out.println(Thread.currentThread().getName() + "开始运行");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "运行结束");

            }
        }, "t1");

        Thread t2 = new Thread(() -> {//不加锁
            System.out.println(Thread.currentThread().getName() + "开始运行");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "运行结束");
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t2运行结束
t1运行结束
```

#### 3.2.synchronized方法

语法格式如下

```java
class Test{
	public synchronized void test() {
        ...
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
			...
		}
	}
}
```

```java
class Test{
	public synchronized static void test() {
        ...
	}
}
等价于
class Test{
	public static void test() {
		synchronized(Test.class) {
			...
		}
	}
}
```

解决问题的代码如下，直接面向对象

```java
class Room {
	int value = 0;
    
	public synchronized void increment() {
		value++;
	}
    public synchronized void decrement() {
        value--;
    }
    public synchronized int get() {
        return value;
    }
}

public class Test1 {
	public static void main(String[] args) throws InterruptedException {
		Room room = new Room();
        
		Thread t1 = new Thread(() -> {
			room.increment();
		}, "t1");
        
		Thread t2 = new Thread(() -> {
			room.decrement();
		}, "t2");
        
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(room.get());
	}
}
```

为了更好的理解**对象锁**，请看以下几个方法，并分析输出情况

```java
//写在方法上的synchronized实际锁的也是对象，看以上的拆解代码就可以知道
//所以就相当于t1和t2同时争抢房间n1的使用权，若t1进入房间n1就将房门锁上，并且持有锁，保证原子性
public class Test01 {
    public static void main(String[] args) {
        Number1 n1 = new Number1();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n1.b(); }, "t2").start();
    }
}

class Number1 {
    public synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t1运行结束
t2开始运行
t2运行结束
```

```java
//这其实就相当于一个加锁一个没加锁的情况，若t1先执行，进入n1房间，关门取锁
//t1中途被踢出房间，t2开始执行，但t2不存在房间的概念，所以它运行它的
//若它中途CPU时间片用完，那么t1会带锁回归到n1，假设此时t1完毕，接着切回t2直到结束，所以还是无法保证原子性
public class Test02 {
    public static void main(String[] args) {
        Number2 n1 = new Number2();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n1.b(); }, "t2").start();
    }
}

class Number2 {
    public synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t1运行结束
t2运行结束
```

```java
//这个不讲了，也无法保证原子性，不同对象不同房子不同锁
public class Test03 {
    public static void main(String[] args) {
        Number3 n1 = new Number3();
        Number3 n2 = new Number3();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n2.b(); }, "t2").start();
    }
}

class Number3 {
    public synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t1运行结束
t2运行结束
```

为了更好的理解**对象锁与类锁**，请看以下几个方法，并分析输出情况

```java
//t1通过n1调用a()，static锁的是类本身，而t2通过n1调用b()，锁的是n1对象，所以两者锁的不同，不保证原子性
public class Test04 {
    public static void main(String[] args) {
        Number4 n1 = new Number4();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n1.b(); }, "t2").start();
    }
}

class Number4 {
    public static synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t2运行结束
t1运行结束
```

```java
//t1通过n1调用a()，static锁的是类本身，而t2通过n2调用b()，锁的是n2对象，所以两者锁的不同，不保证原子性
public class Test05 {
    public static void main(String[] args) {
        Number5 n1 = new Number5();
        Number5 n2 = new Number5();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n2.b(); }, "t2").start();
    }
}

class Number5 {
    public static synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t2开始运行
t2运行结束
t1运行结束
```

```java
//t1通过n1调用a()，static锁的是Number6类本身，而t2通过n1调用b()，static锁的是Number6类本身，所以两者锁的相同，保证原子性
public class Test06 {
    public static void main(String[] args) {
        Number6 n1 = new Number6();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n1.b(); }, "t2").start();
    }
}

class Number6 {
    public static synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public static synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t1运行结束
t2开始运行
t2运行结束
```

```java
//t1通过n1调用a()，static锁的是Number7类本身，而t2通过n2调用b()，static锁的是Number7类本身，所以两者锁的相同，保证原子性
public class Test07 {
    public static void main(String[] args) {
        Number6 n1 = new Number6();
        Number6 n2 = new Number6();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n2.b(); }, "t2").start();
    }
}

class Number7 {
    public static synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public static synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
t1运行结束
t2开始运行
t2运行结束
```

**方法抛出异常后会释放锁**

```java
public class Test01 {
    public static void main(String[] args) {
        Number1 n1 = new Number1();
        new Thread(() -> { n1.a(); }, "t1").start();
        new Thread(() -> { n1.b(); }, "t2").start();
    }
}

class Number1 {
    public synchronized void a() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        throw new RuntimeException();
        //System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public synchronized void b() {
        System.out.println(Thread.currentThread().getName() + "开始运行");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
--------------------------------------------------
t1开始运行
Exception in thread "t1" java.lang.RuntimeException
	at com.yc.Test00_synchronized.exception.Number1.a(Test01.java:31)
	at com.yc.Test00_synchronized.exception.Test01.lambda$main$0(Test01.java:14)
	at java.lang.Thread.run(Thread.java:745)
t2开始运行
t2运行结束
```

## 三、变量的线程安全性分析

### 1.成员变量和静态成员变量是否安全？

若没被共享则线程安全，若被共享则根据它们的状态是否能够改变，又分两种情况，如果只有读操作则线程安全，如果有读写操作则这段代码是临界区，需要考虑线程安全

### 2.局部变量是否安全？

局部变量本身是安全的，但局部变量的引用对象未必，若对象的作用域在方法内部则是安全的，若对象的作用域还在方法外部，需要考虑线程安全，下面具体分析局部变量的安全性

若是基本类型的局部变量，代码如下，则该局部变量只会被保存在每个线程的虚拟机栈中的栈帧中的局部变量表中，如下图

```java
public static void test1() {
	int i = 10;
	i++;
}
```

![1658494849006](assets/1658494849006.png)

若是引用类型的变量，先看一个成员变量的例子，代码如下，由于list是成员变量，而线程中使用的是堆中同一个list，如图，所以两个线程轮询，且线程运行的进度不同，所以可能导致`method3`报错

```java
class ThreadUnsafe {
	ArrayList<String> list = new ArrayList<>();
	public void method1(int loopNumber) {
		for (int i = 0; i < loopNumber; i++) {
			// { 临界区, 会产生竞态条件
			method2();
			method3();
			// } 临界区
		}
	}
	private void method2() {
		list.add("1");
	}
	private void method3() {
		list.remove(0);
	}
}
```

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
	ThreadUnsafe test = new ThreadUnsafe();
	for (int i = 0; i < THREAD_NUMBER; i++) {//创建两个线程
		new Thread(() -> {
			test.method1(LOOP_NUMBER);
		}, "Thread" + i).start();
	}
}
```

![1658495921869](assets/1658495921869.png)

若是引用类型的局部变量，代码如下，则list在线程内部被创建，每个线程都对应一个list，如图，所以不会出现报错问题

```java
class ThreadSafe {
	public final void method1(int loopNumber) {
		ArrayList<String> list = new ArrayList<>();
		for (int i = 0; i < loopNumber; i++) {
			method2(list);
			method3(list);
		}
	}
	private void method2(ArrayList<String> list) {
		list.add("1");
	}
	private void method3(ArrayList<String> list) {
		list.remove(0);
	}
}
```

![1658496006516](assets/1658496006516.png)

试问`method2`和`method3`的修饰符变为`public`还会是安全的吗？以下两种情况会导致不安全，从此处可以看出`private`或`final`提供安全的意义所在，请体会开闭原则中的闭

* 其它线程调用`method2`或`method3`
* 在前一种情况的基础上，为ThreadSafe类添加子类，子类覆盖`method2`或`method3`

### 3.常见线程安全类

Integer、String、StringBuffer、Random、Vector、Hashtable、java.util.concurrent包下的类，具体实现请自己看源码

## 四、Monitor

### 1.Monitor是什么？

Monitor可以翻译成监视器或者管程，由JVM提供的Java对象监视器

### 2.ObjectMonitor结构体

Monitor是基于C++代码中的ObjectMonitor结构体实现的，ObjectMonitor结构体如下

```
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; // 由于synchronized是可重入锁，count用于记录当前对象锁拥有者线程获取锁的次数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; // 调用了wait方法，处于WAIT/TIME_WAIT的线程，会被加入到WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到EntryList
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
}
```

### 3.Monitor原理

JVM中Monitor主要基于ObjectMonitor结构体中的**EntrySet、WaitSet两个队列以及计数器count**实现的

当线程执行到临界区时，首先查看对象头中是否已有关联的Monitor对象，如果已关联则将当前线程添加到Monitor对象的EntryList队列，如果没关联则关联一个Monitor对象，关联后则表示Monitor对象的拥有者变成当前线程，即当前线程获取到某个对象锁，变成锁的拥有者，准备开始运行临界区的代码，执行字节码指令`monitorenter`，此时`count++`，当该线程尝试再次获取锁是执行`count++`，而不是进入EntryList队列阻塞等待，此处体现可重入，当临界区的代码应完成或异常退出时使`count--`，当count变为0则当前线程释放锁，Monitor对象重新到EntryList队列选一个新的拥有者持有锁，一般使非公平竞争，当拥有锁的线程调用`wait()`则线程进入WaitSet，等待`notify()`唤醒或等待时间到达才能变成锁的拥有者，所以`wait()`是释放锁的

一个对象关联一个Monitor对象，当一个对象持有Monitor对象地址后就处理锁定状态，**JVM给每个对象和class字节码都会设置一个监听器Monitor**，用于检测并发代码的重入，**不加synchronized的对象不会关联Monitor**

## 五、wait和notify

在[线程基础](/7.JUC并发编程/线程基础)其实已经了解过`wait()`和`notify()`和`notifyAll()`，此处就只提一句`wait()`会释放锁，且`wait()`必须在`synchronized`内部使用，即必须配合`Monitor`使用，接下来模拟场景步步升级

①使用`synchronized+sleep`的场景导致不释放锁，其他线程也进不来，就一直阻塞，效率太低，请看②

```java
import java.util.concurrent.atomic.AtomicBoolean;
import static java.lang.Thread.sleep;

/**
 * 假设某线程需要工作中需要喝水才能继续工作，以下模拟场景
 */
public class Test01 {
    public static void main(String[] args) throws InterruptedException {
        Object room = new Object();//对象锁
        AtomicBoolean has = new AtomicBoolean(false);//这只是一个原子操作类，先不管

        new Thread(() -> {//这是一个工作线程
            synchronized (room) {
                System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                System.out.println("有水吗？" + has);
                if (!has.get()) {
                    System.out.println("没水？那不干了，找个人来给我送水");
                    System.out.println("--" + Thread.currentThread().getName() + "开始休息");
                    try {
                        sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有水吗？" + has);
                if (has.get()) {
                    System.out.println("终于喝到水了，准备开始干活");
                    System.out.println("--" + Thread.currentThread().getName() + "继续运行");
                }
                System.out.println("--" + Thread.currentThread().getName() + "工作结束");
            }
        }, "工作线程").start();

        for (int i = 0; i < 5; i++) {//大哥不能一直干活，总有结束的时候，但是房间里同时只能有一个人干活
            new Thread(() -> {
                System.out.println("--" + Thread.currentThread().getName() + "等待房间使用权");
                synchronized (room) {
                    System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                    System.out.println("--" + Thread.currentThread().getName() + "工作结束");
                }
            }, "t" + (i + 2)).start();
        }

        sleep(1);//主线程睡一会再让小弟送水

        new Thread(() -> {//这是给大哥送水的线程，注意不能去抢大哥的房间啊，大哥在里面拿着钥匙还锁着门呢，抢大哥的那肯定抢不到啊，此处可以加另一把对象锁或直接不加锁
            has.set(true);
            System.out.println("小弟给送水来了");
        }).start();
    }
}
--------------------------------------------------
--工作线程开始工作
有水吗？false
没水？那不干了，找个人来给我送水
--工作线程开始休息
--t2等待房间使用权
--t3等待房间使用权
--t4等待房间使用权
--t5等待房间使用权
--t6等待房间使用权
小弟给送水来了
有水吗？true
终于喝到水了，准备开始干活
--工作线程继续运行
--工作线程工作结束
--t6开始工作
--t6工作结束
--t5开始工作
--t5工作结束
--t4开始工作
--t4工作结束
--t3开始工作
--t3工作结束
--t2开始工作
--t2工作结束
```

②使用`synchronized+wait+notify`的场景会释放锁，解决阻塞问题，但是`notify()`只会唤醒一个`wait()`，另一个因为一直没被唤醒，所以一直在等待，请看③

```java
import java.util.concurrent.atomic.AtomicBoolean;
import static java.lang.Thread.sleep;

/**
 * 模拟t1线程需要喝水才能继续工作，t2线程需要吃点水果才能继续工作，假设他们都点同一份外卖呢？
 */
public class Test02 {
    public static void main(String[] args) throws InterruptedException {
        Object room = new Object();//对象锁
        AtomicBoolean has = new AtomicBoolean(false);//这只是一个原子操作类，先不管

        new Thread(() -> {//t1需要喝水
            synchronized (room) {
                System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                System.out.println("有水吗？" + has);
                if (!has.get()) {
                    System.out.println("没水？那不干了，找个人来给我送水");
                    System.out.println("--" + Thread.currentThread().getName() + "开始休息");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有水吗？" + has);
                if (has.get()) {
                    System.out.println("终于喝到水了，准备开始干活");
                    System.out.println("--" + Thread.currentThread().getName() + "继续运行");
                    System.out.println("--" + Thread.currentThread().getName() + "完成工作后，工作结束");
                } else {
                    System.out.println("等了这么久还不给水，不干了");
                    System.out.println("--" + Thread.currentThread().getName() + "未完成工作，工作结束");
                }
            }
        }, "t1").start();

        new Thread(() -> {//t2需要吃水果
            synchronized (room) {
                System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                System.out.println("有水果吗？" + has);
                if (!has.get()) {
                    System.out.println("没水果？那不干了");
                    System.out.println("--" + Thread.currentThread().getName() + "开始休息");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有水果吗？" + has);
                if (has.get()) {
                    System.out.println("终于吃到水果了，准备开始干活");
                    System.out.println("--" + Thread.currentThread().getName() + "继续运行");
                }
                System.out.println("--" + Thread.currentThread().getName() + "工作结束");
            }
        }, "t2").start();

        sleep(1);//主线程睡一会再让小弟送水

        new Thread(() -> {
            synchronized (room) {
                has.set(true);
                System.out.println("送外卖的来了，出来拿");
                room.notify();
            }
        }).start();
    }
}
--------------------------------------------------
--t1开始工作
有水吗？false
没水？那不干了，找个人来给我送水
--t1开始休息
--t2开始工作
有水果吗？false
没水果？那不干了
--t2开始休息
送外卖的来了，出来拿
有水吗？true
终于喝到水了，准备开始干活
--t1继续运行
--t1完成工作后，工作结束
//此处程序并没有结束
```

③使用`synchronized+wait+notifyAll`的场景会释放锁，解决阻塞问题，同时唤醒所有因为`wait()`在等待的线程，但是采用`if`的方式就只有一次机会可以判断阻塞条件，唤醒之后会跳出`if`继续向下运行，那如果被唤醒后条件还是不成立呢？所以需要改进成`while`循环

```java
import java.util.concurrent.atomic.AtomicBoolean;
import static java.lang.Thread.sleep;

/**
 * 模拟t1线程需要喝水才能继续工作，t2线程需要吃点水果才能继续工作，假设他们都点同一份外卖呢？
 */
public class Test03 {
    public static void main(String[] args) throws InterruptedException {
        Object room = new Object();//对象锁
        AtomicBoolean has = new AtomicBoolean(false);//这只是一个原子操作类，先不管

        new Thread(() -> {//t1需要喝水
            synchronized (room) {
                System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                System.out.println("有水吗？" + has);
                while (!has.get()) {
                    System.out.println("没水？那不干了，找个人来给我送水");
                    System.out.println("--" + Thread.currentThread().getName() + "开始休息");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有水吗？" + has);
                if (has.get()) {
                    System.out.println("终于喝到水了，准备开始干活");
                    System.out.println("--" + Thread.currentThread().getName() + "继续运行");
                    System.out.println("--" + Thread.currentThread().getName() + "完成工作后，工作结束");
                } else {
                    System.out.println("等了这么久还不给水，不干了");
                    System.out.println("--" + Thread.currentThread().getName() + "未完成工作，工作结束");
                }
            }
        }, "t1").start();

        new Thread(() -> {//t2需要吃水果
            synchronized (room) {
                System.out.println("--" + Thread.currentThread().getName() + "开始工作");
                System.out.println("有水果吗？" + has);
                while (!has.get()) {
                    System.out.println("没水果？那不干了");
                    System.out.println("--" + Thread.currentThread().getName() + "开始休息");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有水果吗？" + has);
                if (has.get()) {
                    System.out.println("终于吃到水果了，准备开始干活");
                    System.out.println("--" + Thread.currentThread().getName() + "继续运行");
                }
                System.out.println("--" + Thread.currentThread().getName() + "工作结束");
            }
        }, "t2").start();

        sleep(1);//主线程睡一会再让小弟送水

        new Thread(() -> {
            synchronized (room) {
                has.set(true);
                System.out.println("送外卖的来了，出来拿");
                room.notifyAll();
            }
        }).start();
    }
}
--------------------------------------------------
--t1开始工作
有水吗？false
没水？那不干了，找个人来给我送水
--t1开始休息
--t2开始工作
有水果吗？false
没水果？那不干了
--t2开始休息
送外卖的来了，出来拿
有水果吗？true
终于吃到水果了，准备开始干活
--t2继续运行
--t2工作结束
有水吗？true
终于喝到水了，准备开始干活
--t1继续运行
--t1完成工作后，工作结束
```

④小结`synchronized+wait+notifyAll`的使用架构

```java
synchronized(lock) {
	while(条件不成立) {//循环是为了使被唤醒后看条件时候成立，若开始不成立则继续等待
		lock.wait();
	}
	//此处条件成立，且被唤醒，则开始干活
}
//另一个线程
synchronized(lock) {
	lock.notifyAll();//唤醒所有等待的线程
}
```

## 六、LockSupport

### 1.LockSupport是什么？

LockSupport内部存在两个重要方法，即`LockSupport.park()`和`LockSupport.unpark(线程对象)`，其中`LockSupport.park()`会检查线程的许可证，若线程没有许可证将会阻塞线程，直到`unpark()`处获取许可证，默认线程是不持有许可证的；`LockSupport.unpark(线程对象)`会给线程对象关联许可证，使线程从`park()`阻塞位置解除阻塞

### 2.park&unpark和wait&notify相比

`wait()`、`notify()`、`notifyAll()`必须配合Monitor使用，即配合`synchronized`使用，而`park()`、`unpark()`不必

`park()`、`unpark()`的解锁顺序灵活，可以先`unpark()`，但`wait()`、`notify()`就不能先`notify()`

`park()`、`unpark()`以线程为单位精确阻塞和唤醒，但`notify()`只能随机唤醒一个等待线程

### 3.使用

①先`park()`再`unpark()`

```java
Thread thread = new Thread(() -> {
    System.out.println("子线程开始park");
    //没有许可证，挂起自己
    LockSupport.park();
    System.out.println("子线程结束");
});

thread.start();

Thread.sleep(1000);
System.out.println("主线程开始unpark");
//让子线程有许可证，park方法返回
LockSupport.unpark(thread);
```

②先`unpark()`再`park()`

```java
System.out.println("开始pack");
//使用当前线程获取许可证
LockSupport.unpark(Thread.currentThread());
//再次调用park，unpark后调用park会立即返回
LockSupport.park();
System.out.println("结束pack");
```

## 七、锁的活跃性

### 1.死锁

**一个线程需要同时获取多把锁，这时就容易发生死锁**，例如如下情况

```java
import static java.lang.Thread.sleep;

public class DeadLock {
    public static void main(String[] args) {
        Object A = new Object();
        Object B = new Object();

        Thread t1 = new Thread(() -> {
            synchronized (A) {//获取A对象锁
                System.out.println("lock A");
                try {
                    sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (B) {//获取B对象锁
                    System.out.println("lock B");
                    System.out.println("t1获得两把锁后的操作");
                }
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            synchronized (B) {//获取B对象锁
                System.out.println("lock B");
                try {
                    sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (A) {//获取A对象锁
                    System.out.println("lock A");
                    System.out.println("t2获得两把锁后的操作");
                }
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

IDEA可查看线程相互等待的情况

![1658558611574](assets/1658558611574.png)

![1658558638860](assets/1658558638860.png)

### 2.活锁

**两个线程互相改变对方的结束条件，最后谁也无法结束**，这是发生活锁，例如如下情况

```java
import static java.lang.Thread.sleep;

public class LiveLock {

    static volatile int count = 10;
    static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            // 期望减到 0 退出循环
            while (count > 0) {
                try {
                    sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count--;
                System.out.println(count);
            }
        }, "t1").start();
        new Thread(() -> {
            // 期望超过 20 退出循环
            while (count < 20) {
                try {
                    sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count++;
                System.out.println(count);
            }
        }, "t2").start();
    }
}
```

### 3.**饥饿**

很多教程中把饥饿定义为**一个线程由于优先级太低始终得不到CPU调度执行，也不能够结束**，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题

## 八、Lock

### 1.ReentrantLock

#### 1.1.基本语法格式

```java
//1.获取锁
reentrantLock.lock();
try {
	//临界区
} finally {
	//2.释放锁，一定不要忽略这个步骤
	reentrantLock.unlock();
}
```

#### 1.2.可重入

可重入表示自己可以第二次获得锁，若不可重入那么自己第二次获取锁时也将被锁住，`synchronized`也可重入

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Re_reentrantLock {
    //Lock接口       ReentrantLock可重入锁
    Lock lock = new ReentrantLock();

    public void set() {
        try {
            lock.lock();
            System.out.println("set");
            get();//同一个线程在set中获取锁又调用get重新获取同一把锁
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();//必须释放锁
        }
    }

    public void get() {
        try {
            lock.lock();//第二次获得锁
            System.out.println("get");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Re_reentrantLock re = new Re_reentrantLock();
        re.set();
    }
}
```

#### 1.3.可打断

可通过`lockInterruptibly()`在等待加锁的过程中被中断，`lock()`方式加锁就不能被打断了，同时可通过`isLocked()`获取锁的状态，`synchronized`不可中断且无法获取锁状态

```java
import java.util.concurrent.locks.ReentrantLock;
import static java.lang.Thread.sleep;

public class Interrupted {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();

        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "启动");
            try {
                lock.lockInterruptibly();
                System.out.println(Thread.currentThread().getName() + "获取可被打断的锁");
            } catch (InterruptedException e) {
                e.printStackTrace();
                System.out.println(Thread.currentThread().getName() + "等锁的过程中被打断");
                return;
            }

            try {
                System.out.println(Thread.currentThread().getName() + "等待锁过程中未被中断，成功获取锁");
            } finally {
                lock.unlock();
                System.out.println(Thread.currentThread().getName() + "释放锁");
            }
        }, "t1");

        lock.lock();//先把锁加给主线程，那么t1线程就必须要等到主线程释放锁才能加锁，在等待过程中可以打断t1线程，查看报错
        System.out.println(Thread.currentThread().getName() + "获得锁");
        t1.start();
        try {
            sleep(1);//等待t1线程到达等待锁的状态
            t1.interrupt();//打断
            System.out.println("执行打断");
        } finally {
            lock.unlock();
        }
    }
}
--------------------------------------------------
main获得锁
t1启动
执行打断
t1等锁的过程中被打断
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
	at com.yc.Test04_shareproblem.Test04_Lock.Interrupted.lambda$main$0(Interrupted.java:20)
	at java.lang.Thread.run(Thread.java:745)  
```

#### 1.4.锁超时

可通过`tryLock()`和`tryLock(long time, TimeUnit unit)`尝试获取锁，返回布尔结果，`synchronized`不能设置超时时间

①`boolean tryLock()`判断锁可不可以，然后立即返回结果，模拟**立即失败**

```java
import java.util.concurrent.locks.ReentrantLock;
import static java.lang.Thread.sleep;

public class tryLock {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();

        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "启动");
            if (!lock.tryLock()) {
                System.out.println(Thread.currentThread().getName() + "获取锁失败，立刻返回");
                return;
            }
            try {
                System.out.println(Thread.currentThread().getName() + "成功获取锁");
            } finally {
                lock.unlock();
            }
        }, "t1");

        lock.lock();
        System.out.println(Thread.currentThread().getName() + "获得锁");
        t1.start();
        try {
            sleep(2);
        } finally {
            lock.unlock();
        }

    }
}
--------------------------------------------------
main获得锁
t1启动
t1获取锁失败，立刻返回
```

②`boolean tryLock(long time, TimeUnit unit)`判断锁可不可以，然后在规定时间内返回结果，模拟**超时失败**

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class tryLockTime {
    public static void main(String[] args) throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();

        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "启动");
            try {
                if (!lock.tryLock(2, TimeUnit.SECONDS)) {
                    System.out.println(Thread.currentThread().getName() + "获取锁失败，超时返回");
                    return;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                System.out.println(Thread.currentThread().getName() + "成功获取锁");
            } finally {
                lock.unlock();
            }
        }, "t1");

        lock.lock();
        System.out.println(Thread.currentThread().getName() + "获得锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(3);
        } finally {
            lock.unlock();
        }

    }
}
--------------------------------------------------
main获得锁
t1启动
t1获取锁失败，超时返回
```

#### 1.5.公平锁

ReentrantLock默认是不公平锁，可通过`new ReentrantLock(true)`设置公平锁，`synchronized`只能是非公平锁，就不证明了

#### 1.6.条件变量

`synchronized`中也有条件变量，就是`waitSet`，当条件不满足时进入`waitSet`，ReentrantLock条件变量的强大之处在于它支持多个条件，这就好比`synchronized`只有一间休息室，而ReentrantLock有好几间

ReentrantLock可通过`newCondition()`设置条件，`newCondition()`返回Condition类，Condition类中含以下几个方法

* `await()`：相当`Object.wait()`，执行前需要获取锁`lock()`，执行后会释放锁，进入`conditionObject`等待，**若被唤醒、打断、超时需要重新获取锁，重新获取锁后继续从`await()`后执行**
* `singal()`：相当`Object.notify()`，随机唤醒`conditionObject`中等待的
* `singalAll()`：相当`Object.notifyAll()`

①**同步模型之顺序控制**：使abc三个方法按`a-b-c`的顺序调用，利用`wait+notifyAll`

```java
public class NoConditionDemo1 {
    private int signal;

    public synchronized void a() {
        while (signal != 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("a" + signal);
        signal++;
        notifyAll();
    }

    public synchronized void b() {
        while (signal != 1) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("b" + signal);
        signal++;
        notifyAll();
    }

    public synchronized void c() {
        while (signal != 2) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("c" + signal);
        signal = 0;
        notifyAll();
    }

    public static void main(String[] args) {
        //整个程序 一直以   a0,b1,c2输出 .
        NoConditionDemo1 d = new NoConditionDemo1();
        A a = new A(d);
        B b = new B(d);
        C c = new C(d);
        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();

        new Thread(c).start();
        new Thread(c).start();
        new Thread(c).start();
        new Thread(c).start();

        new Thread(b).start();
        new Thread(b).start();
        new Thread(b).start();
        new Thread(b).start();
    }
}

// A B C三个类，用来表示多个线程调用DemoNoCondition的几个方法来打印abc
class A implements Runnable {
    private NoConditionDemo1 demoCondition;

    public A(NoConditionDemo1 demo) {
        this.demoCondition = demo;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.a();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class B implements Runnable {
    private NoConditionDemo1 demoCondition;

    public B(NoConditionDemo1 demoCondition) {
        this.demoCondition = demoCondition;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.b();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class C implements Runnable {
    private NoConditionDemo1 demoCondition;

    public C(NoConditionDemo1 demoCondition) {
        this.demoCondition = demoCondition;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.c();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

②**同步模型之顺序控制**：使abc三个方法按`a-b-c`的顺序调用，利用`await+signal`

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ConditionDemo2 {
    private int signal;

    private final Lock lock = new ReentrantLock();

    private final Condition a = lock.newCondition();
    private final Condition b = lock.newCondition();
    private final Condition c = lock.newCondition();

    public void a() {
        lock.lock();
        try {
            while (signal != 0) {
                try {
                    a.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("a" + signal);
            signal++;
            b.signal();
        } finally {
            lock.unlock();
        }
    }

    public void b() {
        lock.lock();
        try {
            while (signal != 1) {
                try {
                    b.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("b" + signal);
            signal++;
            c.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void c() {
        lock.lock();
        try {
            while (signal != 2) {
                try {
                    c.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("c" + signal);
            signal = 0;
            a.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        //整个程序 一直以   a0,b1,c2输出 .
        ConditionDemo2 d = new ConditionDemo2();
        A1 a = new A1(d);
        B1 b = new B1(d);
        C1 c = new C1(d);
        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();
        new Thread(a).start();

        new Thread(c).start();
        new Thread(c).start();
        new Thread(c).start();
        new Thread(c).start();

        new Thread(b).start();
        new Thread(b).start();
        new Thread(b).start();
        new Thread(b).start();
    }
}

class A1 implements Runnable {
    private ConditionDemo2 demoCondition;

    public A1(ConditionDemo2 demo) {
        this.demoCondition = demo;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.a();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class B1 implements Runnable {
    private ConditionDemo2 demoCondition;

    public B1(ConditionDemo2 demoCondition) {
        this.demoCondition = demoCondition;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.b();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class C1 implements Runnable {
    private ConditionDemo2 demoCondition;

    public C1(ConditionDemo2 demoCondition) {
        this.demoCondition = demoCondition;
    }

    @Override
    public void run() {
        while (true) {
            demoCondition.c();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**③异步模型之生产者消费者**：利用`await+signal`模拟生产者和消费者

```java
class AppleBox {
    int index = 0;
    Apple[] apples = new Apple[5];

	//创建锁，替换synchronized
	private final Lock lock = new ReentrantLock();
	//一个锁可以有多个等待队列
	private final Condition produceCondition = lock.newCondition();
	private final Condition consumeCondition = lock.newCondition();

    //生产
    public void deposite(Apple apple) throws InterruptedException {
        lock.lock();

        try {
            //存满，如果产品一直没被消费，则产品就一直往produceCondition存
            while (index == apples.length) {//不要if，醒来之后需要判断index，防止index越界，多次容错
                produceCondition.await();
            }
            consumeCondition.signal();//唤醒消费者从await醒来再次判断是不是空，不空就要继续向下消费index--
            apples[index] = apple;
            index++;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    //消费
    public Apple withdraw() {
        lock.lock();

        try {
            //空的，如果容器一直没产品，则消费者一直往consumeCondition等待
            while (index == 0) {//不要if，醒来之后需要判断index，防止index越界，多次容错
                consumeCondition.await();
            }
            produceCondition.signal();//唤醒生产者从await醒来再次判断是不是满，不满就要继续生产index++
            index--;
            return apples[index];
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return null;
    }
}
```

#### 1.7.Lock与synchronized比较

![1658567271396](assets/1658567271396.png)

### 2.ReentrantReadWriteLock

ReentrantReadWriteLock称为读写锁，使读操作和写操作各有一把锁，**读锁与写锁不能同时拥有，读锁在读操作间共享，写锁在读写操作间都独占(排他锁)，适用于读多写少的情况**

看以下的使用案例

```java
/**
- 需求：两个读线程，两个写线程，4个线程同时启动(CyclicBarrier)，测试这4个线程的读写顺序
- 1.当有读锁时，不能加写锁，且读锁在读操作共享
- 2.当有写锁时，不能加读锁，且写锁排他，其他读操作也不能进行
 */
public class ReentrantReadWriteLockTest {
	//读写锁
	private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    //线程池
	private static ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
    //栏杆
	private static CyclicBarrier cyclicBarrier = new CyclicBarrier(4);
	private static int i = 100;

    //读操作
	public static void read(Thread thread) {
		//在此处等待，等待同时运行信号
        try {
            cyclicBarrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }

  		//读锁：抢到读锁，则两个读锁线程可以同时向下运行-->读锁共享
  		reentrantReadWriteLock.readLock().lock();
  
  		//读线程 pool-1-thread-3 开始执行  i=100
  		//读线程 pool-1-thread-2 开始执行  i=100
  		//读线程 pool-1-thread-2 结束
  		//读线程 pool-1-thread-3 结束
  
        try {
            System.out.println("读线程 " + thread.getName() + " 开始执行  i=" + i);
            Thread.sleep(1000);
            System.out.println("读线程 " + thread.getName() + " 结束");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            reentrantReadWriteLock.readLock().unlock();
        }
  	}

    //写操作
    public static void write(Thread thread) {
        //在此处等待，等待同时运行信号
        try {
            cyclicBarrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }

        //写锁：只能有一个在写，且不能读
        reentrantReadWriteLock.writeLock().lock();
  
        //写线程 pool-1-thread-1 开始执行  i=101
        //写线程 pool-1-thread-1 结束
        //写线程 pool-1-thread-2 开始执行  i=102
        //写线程 pool-1-thread-2 结束
  
        try {
            i++;
            System.out.println("写线程 " + thread.getName() + " 开始执行  i=" + i);
            System.out.println("写线程 " + thread.getName() + " 结束");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            reentrantReadWriteLock.writeLock().unlock();
        }
	}

    public static void main(String[] args) {
        //提交任务到线程池
        executor.execute(() -> {
            write(Thread.currentThread());
        });
        executor.execute(() -> {
            write(Thread.currentThread());
        });
        executor.execute(() -> {
            read(Thread.currentThread());
        });
        executor.execute(() -> {
            read(Thread.currentThread());
        });
        executor.shutdown();
    }
}
```

## 九、AQS

### 1.AQS是什么？

一. AQS是什么
队列同步器AbstractQueuedSynchronizer(简称为AQS)，是用来构建锁或者其他同步组件的基础框架，通过内置的FIFO(先来先服务)队列来完成资源获取线程的排队工作。AQS是实现锁的关键，简单理解两者的关系就是：锁是面向使用者的；AQS面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理，线程排队，等待唤醒底层操作的细节，对外放出模板方法供子类实现。
————————————————
版权声明：本文为CSDN博主「AgainLujinge」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_46566541/article/details/119141525

















锁类型
1.可重入锁
同一个线程多次获取同一把锁不用切上下文
2.公平锁
多个线程按照申请锁的顺序获得锁
线程会直接进入队列去排队
永远都是队列的第一位才能得到锁
排队不插队
优点
所有的线程都能得到资源，不会饿死在队列中
1
缺点
吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大
1
源码


3.非公平锁
多个线程申请锁时，直接尝试获取锁，获取不到进入队列去排队
优点
减少CPU唤醒线程的开销，整体的吞吐效率会高点，减少CPU唤起线程的数量
1
缺点
导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死
1
4.自旋锁
//需求: 利用CAS完成一个自旋锁，以安全的自增
public class SafeIncrement {
    private AtomicInteger atomicI = new AtomicInteger(0);
    
    public void increament() {
        for (;;) {//自旋
            int i = atomicI.get();//另外线程  可能修改过i值
            boolean suc = atomicI.compareAndSet(i, ++i);
            if (suc) {//i修改成功则跳出循环
                break;
            }
        }
    }








