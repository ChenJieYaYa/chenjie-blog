# 有锁编程

## 一、共享带来的问题

两个线程对初始值为0的静态变量，一个做自增，一个做自减，结果是0吗？

```java
static int i = 0;
public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		i++;
	}, "t1");
    
	Thread t2 = new Thread(() -> {
		i--;
	}, "t2");
    
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	System.out.println(i);
}
```

结果正数、负数、零都有，为什么呢？接下来从字节码开始步步深入🙃

对于`i++`而言，实际会产生如下的JVM字节码指令，`i--`也类似，可看到分成四步

```java
getstatic i	//获取静态变量i的值
iconst_1	//准备常量1
iadd		//自增，i--改成 isub
putstatic i //将修改后的值存入静态变量i
```

通过上一张图解可知，完成静态变量自增和自减需要在主内存与线程工作内存间进行数据交换

![1658372661291](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658372661291.png)

对于单线程，以上自增和自减的8条字节码指令顺序执行，不会存在什么问题，但对多线程来说这8条指令可能交错运行，即线程1可能运行到第三条指令就切换上下文给线程2，线程2若顺利的运行完则将结果-1写回主存，此时继续执行线程1的第三天指令则将结果1写回主存，最终主存中i的结果为1，当然这8条字节码指令间还存在各种交替方式，所以最终i的值可能为正数、负数或零

**其实程序运行多线程本身是不存在问题的，问题出现在多线程访问共享资源，或者说多线程访问共享资源也没问题，问题出现在多线程对共享变量读写操作时发生指令交错**，出现了问题当然就要解决，请接着往下看<span style="color:green">大标题就是解决方案</span>

对共享资源多线程读写操作的代码块称为**临界区**，多线程在临界区内运行，由于字节码指令执行顺序不同而导致结果无法预测称为发生**竞态条件**

```java
static int i = 0;
static void increment()
//临界区
{	i++;	}
static void decrement()
//临界区
{	i--;	}
```

## 二、synchronized

### 1.什么是synchronized？

`synchronized`又称对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程想要获取对象锁时会被阻塞

`synchronized`用于解决多线程操作同一资源时数据不一致问题，即**资源争抢问题**，保证持有锁的线程可以安全的执行临界区的代码，不用担心指令交替运行，解决并发编程三大特性之**原子性**

![1658300586029](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658300586029.png)

![1658300599862](../7.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/assets/1658300599862.png)

### 2.synchronized解决共享带来的问题

#### 2.1.synchronized代码块

语法格式如下

```java
synchronized(对象)//线程1，线程2(blocked)
{
	临界区
}
```

解决问题的代码如下

```java
static int i = 0;
static final Object room = new Object();

public static void main(String[] args) throws InterruptedException {
	Thread t1 = new Thread(() -> {
		synchronized (room) {
            i++;
        }
	}, "t1");
    
	Thread t2 = new Thread(() -> {
		synchronized (room) {
            i--;
        }
	}, "t2");
    
	t1.start();
	t2.start();
	t1.join();
	t2.join();
	System.out.println(i);
}
```

以上代码如何理解呢？请继续往下康

`synchronized(对象)`中的对象相当于一个房间`room`，该房间只有唯一的入口，每次只能有一人进入，线程t1、t2想象成两个人，当线程t1执行`synchronized(room)`，相当于t1到达房间就把房门锁上，并拿走了钥匙，在房间内执行`i++`，若此时t2执行`synchronized(room)`，但发现房门被锁住，就只能在门外等，发生阻塞，恰好此时线程t1的CPU时间片用完，即使用房间的时间用完，那么t1将被提出门外，注意**t1被提出门外时还是带着钥匙的，而且房间门也没开**，所以t2还是在门外等，等待CPU再次轮询到t1时，他带着钥匙光荣回归，t1再次占用房间，当t1执行完`synchronized{}`内的任务才会开门出来，唤醒并把锁交给t2，这是t2才可以进入房间，继续关门...

以上通俗的表达相信你已经理解了`synchronized(){}`的工作原理，实际**`synchronized`使用对象锁保证临界区代码的原子性，使临界区的操作不可分割**，继续请思考以下几个问题🤯

* 如果把`synchronized(obj)`放在`for`循环的外面如何理解？原子性
* 如果`t1 synchronized(obj1)`而`t2 synchronized(obj2)`会怎样运作？锁对象，若t1先执行，进入obj1房间，关门取锁，中途被踢出房间，t2开始执行，但t2进入的是obj2房间，同样关门取锁，若t2顺利运行完，则会再次切回t1，即结果临界区内代码无法保证原子性
* 如果`t1 synchronized(obj)`而`t2`没有加会怎么样？如何理解？锁对象，若t1先执行，进入obj1房间，关门取锁，中途被踢出房间，t2开始执行，但t2不存在房间的概念，所以它运行它的，若它中途CPU时间片用完，那么t1会带锁回归到obj1，假设此时t1完毕，接着切回t2直到结束，所以还是无法保证原子性

Java是面向对象的语言，所以面向对象改进

```java
class Room {
	int value = 0;
    
	public void increment() {
		synchronized (this) {
			value++;
        }
	}
    public void decrement() {
        synchronized (this) {
            value--;
        }
    }
    public int get() {
        synchronized (this) {
            return value;
        }
    }
}

public class Test1 {
	public static void main(String[] args) throws InterruptedException {
		Room room = new Room();
        
		Thread t1 = new Thread(() -> {
			room.increment();
		}, "t1");
        
		Thread t2 = new Thread(() -> {
			room.decrement();
		}, "t2");
        
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(room.get());
	}
}
```

#### 2.2.synchronized方法

语法格式如下

```java
class Test{
	public synchronized void test() {
        ...
	}
}
等价于
class Test{
	public void test() {
		synchronized(this) {
			...
		}
	}
}
```

```java
class Test{
	public synchronized static void test() {
        ...
	}
}
等价于
class Test{
	public static void test() {
		synchronized(Test.class) {
			...
		}
	}
}
```

看以下几个方法，分析输出情况

```java
//写在方法上的synchronized实际锁的也是对象，看以上的拆解代码就可以知道，所以就相当于t1和t2同时争抢房间n1的使用权，若t1进入房间n1就将房门锁上，所以结果只有两种可能，12或21
class Number{
	public synchronized void a() {
        System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n1.b(); }).start();//t2
}
```

```java
//同样t1和t2争抢房间n1，要么t1争抢到，t1运行完再放锁给t2；要么t2争抢到，t2运行完再放锁给t1，所以结果也只有两种，1s 12或2 1s 1
class Number{
	public synchronized void a() {
        sleep(1);
        System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n1.b(); }).start();//t2
}
```

```java
//t1和t2和t3都在n1房间操作
//1.若t1抢到n1房间，则会锁上房门，并且手拿钥匙，就算中途上下文切换，即被踢出房间也不会让出房间n1，等到自己执行完后才会唤醒t2或t3
//2.若t2抢到n1房间，则会锁上房门，并且手拿钥匙，就算中途上下文切换，即被踢出房间也不会让出房间n1，等到自己执行完后才会唤醒t1或t3
//3.若t3抢到n1房间，不会对房间上锁，更不存在钥匙一说，若中途上下文切换，即被踢出房间，t1和t2都有可能占有房间，所以若t3内部执行的不是原子操作，很可能发生指令交替
//综上结果有三种，1s 123或1s 132或2 1s 13或23 1s 1或3 1s 12或32 1s 1
class Number{
	public synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
	public void c() {
		System.out.println("3");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n1.b(); }).start();//t2
	new Thread(()->{ n1.c(); }).start();//t3
}
```

```java
//2 1s 后 1
class Number{
	public synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	Number n2 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n2.b(); }).start();//t2
}
```

```java
//2 1s 后 1
class Number{
	public static synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n1.b(); }).start();//t2
}
```

```java
1s 后12， 或 2 1s后 1
class Number{
	public static synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public static synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n1.b(); }).start();//t2
}
```

```java
2 1s 后 1
class Number{
	public static synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	Number n2 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n2.b(); }).start();//t2
}
```

```java
1s 后12， 或 2 1s后 1
class Number{
	public static synchronized void a() {
		sleep(1);
		System.out.println("1");
	}
	public static synchronized void b() {
		System.out.println("2");
	}
}
public static void main(String[] args) {
	Number n1 = new Number();
	Number n2 = new Number();
	new Thread(()->{ n1.a(); }).start();//t1
	new Thread(()->{ n2.b(); }).start();//t2
}
```

## 三、变量的线程安全性分析

### 1.成员变量和静态成员变量是否安全？

若没被共享则线程安全，若被共享则根据它们的状态是否能够改变，又分两种情况，如果只有读操作则线程安全，如果有读写操作则这段代码是临界区，需要考虑线程安全

### 2.局部变量是否安全？

局部变量本身是安全的，但局部变量的引用对象未必，若对象的作用域在方法内部则是安全的，若对象的作用域还在方法外部，需要考虑线程安全，下面具体分析局部变量的安全性

若是基本类型的局部变量，代码如下，则该局部变量只会被保存在每个线程的虚拟机栈中的栈帧中的局部变量表中，如下图

```java
public static void test1() {
	int i = 10;
	i++;
}
```

![1658494849006](assets/1658494849006.png)

若是引用类型的变量，先看一个成员变量的例子，代码如下，由于list是成员变量，而线程中使用的是堆中同一个list，如图，所以两个线程轮询，且线程运行的进度不同，所以可能导致`method3`报错

```java
class ThreadUnsafe {
	ArrayList<String> list = new ArrayList<>();
	public void method1(int loopNumber) {
		for (int i = 0; i < loopNumber; i++) {
			// { 临界区, 会产生竞态条件
			method2();
			method3();
			// } 临界区
		}
	}
	private void method2() {
		list.add("1");
	}
	private void method3() {
		list.remove(0);
	}
}
```

```java
static final int THREAD_NUMBER = 2;
static final int LOOP_NUMBER = 200;
public static void main(String[] args) {
	ThreadUnsafe test = new ThreadUnsafe();
	for (int i = 0; i < THREAD_NUMBER; i++) {//创建两个线程
		new Thread(() -> {
			test.method1(LOOP_NUMBER);
		}, "Thread" + i).start();
	}
}
```

![1658495921869](assets/1658495921869.png)

若是引用类型的局部变量，代码如下，则list在线程内部被创建，每个线程都对应一个list，如图，所以不会出现报错问题

```java
class ThreadSafe {
	public final void method1(int loopNumber) {
		ArrayList<String> list = new ArrayList<>();
		for (int i = 0; i < loopNumber; i++) {
			method2(list);
			method3(list);
		}
	}
	private void method2(ArrayList<String> list) {
		list.add("1");
	}
	private void method3(ArrayList<String> list) {
		list.remove(0);
	}
}
```

![1658496006516](assets/1658496006516.png)

试问`method2`和`method3`的修饰符变为`public`还会是安全的吗？以下两种情况会导致不安全，从此处可以看出`private`或`final`提供安全的意义所在，请体会开闭原则中的闭

* 其它线程调用`method2`或`method3`
* 在前一种情况的基础上，为ThreadSafe类添加子类，子类覆盖`method2`或`method3`

### 3.常见线程安全类







