# çº¿ç¨‹å¹¶å‘å·¥å…·ç±»

## ä¸€ã€Fork-Join

### 1.ä»€ä¹ˆæ˜¯Fork-Joinï¼Ÿ

é¡¾åæ€ä¹‰ï¼ŒFork - Joinçš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯**åˆ†è€Œæ²»ä¹‹**ï¼Œç±»ä¼¼äºå¤§æ•°æ®å¼€å‘çš„MapReduce

![1658453420384](assets/1658453420384.png)

### 2.ä½¿ç”¨æµç¨‹

![1658453803988](assets/1658453803988.png)

### 3.ForkJoinPool

ForkJoinPoolæœ‰å¤šä¸ªå·¥ä½œé˜Ÿåˆ—ï¼Œå½“é€šè¿‡ForkJoinPoolçš„`invoke`ã€`submit`ã€`execute`æäº¤ä»»åŠ¡æ—¶ä¼šæ ¹æ®ä¸€å®šè§„åˆ™åˆ†é…ç»™ä¸åŒçš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶ä¸”**ä»»åŠ¡é˜Ÿåˆ—æ˜¯åŒç«¯é˜Ÿåˆ—**

ä¸ºä»€ä¹ˆè¦ä½¿ç”¨åŒç«¯é˜Ÿåˆ—å‘¢ï¼Ÿå½“ç„¶æ˜¯ä¸ºäº†**å®ç°å·¥ä½œå¯†å–è€Œä¸ä¼šå‘ç”Ÿä»»åŠ¡äº‰æŠ¢çš„æƒ…å†µ**ï¼Œå½“æŸä¸ªå·¥ä½œçº¿ç¨‹å¯¹åº”çš„æ¶ˆè´¹ä»»åŠ¡é˜Ÿåˆ—ç©ºé—²æ—¶ï¼Œå›å»å…¶ä»–å·¥ä½œé˜Ÿåˆ—çš„é˜Ÿå°¾å–ä»»åŠ¡è¿‡æ¥åˆ†æ‹…(Stealing)ï¼Œè€Œå…¶ä»–é˜Ÿåˆ—çš„å¯¹å¤´ä»»åŠ¡ä»ç„¶æä¾›ç»™ä»–çš„æ¶ˆè´¹çº¿ç¨‹

> å¤šçº¿ç¨‹å¼€å‘æ ¸å¿ƒï¼šå¿«ã€å……åˆ†åˆ©ç”¨èµ„æºã€èµ„æºä¸èƒ½äº‰æŠ¢

![1658455241138](assets/1658455241138.png)

### 4.ForkJoinTask

é¡¾åæ€ä¹‰ï¼Œè¿™å°±æ˜¯åˆ†æ²»çš„ä»»åŠ¡ï¼Œç›¸å½“äºå¹³æ—¶ä½¿ç”¨çš„`Runnable`ï¼Œæ ¸å¿ƒæ–¹æ³•æ˜¯`fork`å’Œ`join`ï¼Œ`fork()`å°†æŸå­ä»»åŠ¡å‘ç”Ÿç»™ForkJoinæ‰§è¡Œå™¨ï¼Œç”¨æ¥å¼‚æ­¥æ‰§è¡Œä¸€ä¸ªå­ä»»åŠ¡ï¼Œ`join()`ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç­‰å¾…å­ä»»åŠ¡ç»“æŸå¹¶è¿”å›ç»“æœ

`ForkJoinTask`æœ‰ä¸¤ä¸ªå­ç±»åˆ†åˆ«æ˜¯`RecursiveAction`å’Œ`RecursiveTask`ï¼Œä¸¤ä¸ªå­ç±»éƒ½æœ‰æŠ½è±¡æ–¹æ³•`compute`ï¼Œå·®åˆ«åœ¨äº`RecursiveAction`çš„æ²¡æœ‰è¿”å›å€¼ï¼Œè€Œ`RecursiveTask`æœ‰è¿”å›å€¼

### 5.ç®€å•åº”ç”¨

éœ€æ±‚ï¼šforkjoinæ–¹å¼åœ¨æŒ‡å®šç›®å½•(å«å­ç›®å½•)å¯»æ‰¾æŒ‡å®šåç¼€åçš„æ–‡ä»¶å¹¶æ‰“å°

```java
public class ForkJoin_FindDirsFiles extends RecursiveAction {
    //å½“å‰ä»»åŠ¡éœ€è¦æœå¯»çš„ç›®å½•
    private File path;
    public ForkJoin_FindDirsFiles(File path) {this.path = path;}

    @Override //æ— è¿”å›å€¼
    protected void compute() {
        //æ‰€æœ‰å­ä»»åŠ¡ä¿å­˜åœ¨è¯¥åˆ—è¡¨ä¸­ï¼Œä¸€è¾¹ä¸€æ¬¡æ€§æ¿€æ´»
        List<ForkJoin_FindDirsFiles> subTasks = new ArrayList<>();
        File[] files = path.listFiles();
        if (files != null) {
            for (File file : files) {
                //å¦‚æœæ˜¯æ–‡ä»¶å¤¹ï¼Œæ‹†åˆ†æˆæ–°å­ä»»åŠ¡
                if (file.isDirectory()) {
                    ForkJoin_FindDirsFiles sonTask = new ForkJoin_FindDirsFiles(file);
                    subTasks.add(sonTask);
                } else {
                    //å¦‚æœæ˜¯æ–‡ä»¶ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯éœ€è¦æ‰¾çš„æ–‡ä»¶
                    if (file.getAbsolutePath().endsWith("txt")) {
                        System.out.println("æ–‡ä»¶ï¼š" + file.getAbsolutePath());
                    }
                }
            }
            //å­ä»»åŠ¡åˆ—è¡¨éç©º
            if (!subTasks.isEmpty()) {
                //è°ƒç”¨invokeAllæ¿€æ´»æ‰€æœ‰å­ä»»åŠ¡
                for (ForkJoin_FindDirsFiles subTask : invokeAll(subTasks)) {
                    //joinçš„ç›®çš„ï¼šç­‰å¾…å­ä»»åŠ¡å®Œæˆ
                    subTask.join();
                }
            }
        }
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        try {
            //1.åˆ›å»ºçº¿ç¨‹æ± 
            ForkJoinPool pool = new ForkJoinPool();
            //2.äº§ç”Ÿç¬¬ä¸€ä¸ªå­ä»»åŠ¡
            ForkJoin_FindDirsFiles task = new ForkJoin_FindDirsFiles(new File("c:/"));

            //å¼‚æ­¥è°ƒç”¨ï¼Œæ²¡æœ‰è¿”å›å€¼
            //pool.execute(task);
            //3.åŒæ­¥è°ƒç”¨
            pool.invoke(task);
            System.out.println("ä»»åŠ¡è¿è¡Œä¸­");
            
            //ä¸»çº¿ç¨‹ç¡
            Thread.sleep(1);
            int otherWork = 0;
            for (int i = 0; i < 100; i++) {
                otherWork = otherWork + 1;
            }
            System.out.println("ä¸»çº¿ç¨‹åœ¨å®Œæˆå…¶ä»–å·¥ä½œï¼Œæ­¤å·¥ä½œç»“æŸ" + otherWork);

            //é˜»å¡å¼æ–¹æ³•ï¼Œä¸»çº¿ç¨‹è®©æ­¥ç»™taskçº¿ç¨‹
            task.join();

            System.out.println("ä»»åŠ¡ç»“æŸ");
            System.out.println("è€—æ—¶ï¼š" + (System.currentTimeMillis() - start));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

## äºŒã€CountDownLatch

### 1.ä»€ä¹ˆæ˜¯CountDownLatchï¼Ÿ

CountDownLatchç›¸å½“äºçº¿ç¨‹è®¡æ•°å™¨ï¼Œä¸€ç»„çº¿ç¨‹ç­‰å¾…ï¼Œå…ˆå®Œæˆå…¶ä»–å·¥ä½œåå†æ‰§è¡Œè¿™ä¸€ç»„çº¿ç¨‹ï¼Œç›¸å½“äºåŠ å¼ºç‰ˆçš„`join()`ï¼Œ**ä½†è§£å†³`join()`ä¸çŸ¥é“ç­‰å¾…çº¿ç¨‹ä»€ä¹ˆæ—¶å€™å¼€å§‹ç»§ç»­è¿è¡Œçš„é—®é¢˜**

CountDownLatchä¸­åŒ…å«`await`å’Œ`countDown`æ–¹æ³•ï¼Œ`await()`ä½¿çº¿ç¨‹åœ¨æ­¤å¤„é˜»å¡ï¼Œ`countDown()`ä¼šä½¿`new CountDownLatch(åˆå§‹å€¼)`ä¸­çš„åˆå§‹å€¼å‡1ï¼Œå½“åˆå§‹å€¼å‡ä¸º0åˆ™åœ¨`await()`é˜»å¡çš„çº¿ç¨‹å°†å…¨éƒ¨ç»§ç»­è¿è¡Œ

### 2.ç®€å•åº”ç”¨

```java
//ä¸€ç»„çº¿ç¨‹ç­‰å¾…ï¼Œæ¨¡æ‹Ÿå¹¶å‘ï¼Œä½¿å¹¶å‘çº¿ç¨‹ä¸€èµ·æ‰§è¡Œ
public class CountDownLatch1 {
    public static void main(String[] args) throws InterruptedException {
        final CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                try {
                    //å¾ªç¯åˆ›å»ºçš„5ä¸ªçº¿ç¨‹å…¨éƒ¨é˜»å¡æ­¤å¤„
                    String name = "[" + Thread.currentThread().getName() + "]";
                    System.out.println(name + "é˜»å¡");
                    countDownLatch.await();
                    String str = "[" + Thread.currentThread().getName() + "]";
                    System.out.println(str + "å¼€å§‹æ‰§è¡Œ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        //ä¸»çº¿ç¨‹ç¡çœ 
        Thread.sleep(2000);
        System.out.println("ä¸»çº¿ç¨‹åœ¨è¿è¡Œ");
        //è®¡æ•°å™¨å‡1ï¼Œ5ä¸ªçº¿ç¨‹éƒ½è¿è¡Œ
        countDownLatch.countDown();
    }
}
```

## ä¸‰ã€CyclicBarrier

### 1.ä»€ä¹ˆæ˜¯CyclicBarrierï¼Ÿ

CyclicBarrierå…ˆå½“äºå›ç¯æ …æ ï¼Œå½“çº¿ç¨‹è¾¾åˆ°é˜»å¡æ•°é‡æ—¶ï¼Œæ”¾å¼€æ æ†ï¼Œä½¿æ‰€æœ‰é˜»å¡çš„çº¿ç¨‹ç»§ç»­è¿è¡Œ

CyclicBarrieråªæœ‰`await`æ–¹æ³•ï¼Œå½“åœ¨`await()`å¤„é˜»å¡çš„çº¿ç¨‹æ•°é‡è¾¾åˆ°`new CyclicBarrier(å‚ä¸è€…æ•°é‡)`ä¸­æŒ‡å®šçš„å‚ä¸è€…æ•°é‡æ—¶ï¼Œæ‰€æœ‰é˜»å¡çº¿ç¨‹è§£é™¤é˜»å¡ï¼ŒCyclicBarrierè¿˜æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œå³`CyclicBarrier(å‚ä¸è€…æ•°é‡,Runnable)`ï¼Œå½“æ æ†å¼€æ”¾æ—¶ï¼Œå‚æ•°2å®šä¹‰çš„ä»»åŠ¡ä¼šè¢«æ‰§è¡Œä¸€æ¬¡

### 2.ç®€å•åº”ç”¨

```java
public class UseCyclicBarrier {
    //å‚æ•°ï¼šå‚ä¸çº¿ç¨‹æ•°é‡(æœ‰è¿™ä¹ˆå¤šçº¿ç¨‹ä¸Šæ¥å°±ç»“æŸå±éšœ)
    //private static CyclicBarrier barrier = new CyclicBarrier(5);
    //å±éšœè§£å¼€åæ‰§è¡Œå¦ä¸€ä¸ªä»»åŠ¡
    private static CyclicBarrier barrier = new CyclicBarrier(5, new CollectThread());

    public static void main(String[] args) {
        for (int i = 0; i <= 4; i++) {
            Thread thread = new Thread(new SubThread());
            thread.start();
        }
    }

    //å±è”½å¼€æ”¾ä»¥åçš„å·¥ä½œ
    private static class CollectThread implements Runnable {
        @Override
        public void run() {
            System.out.println("æ‰§è¡Œé†’æ¥åçš„å¦ä¸€ä¸ªå¤„ç†");
        }
    }

    //å·¥ä½œçº¿ç¨‹
    private static class SubThread implements Runnable {
        @Override
        public void run() {
            Random rd = new Random();
            try {
                if (rd.nextBoolean()) {//æ­¤å¤„ä¸ºäº†æ¨¡æ‹Ÿçº¿ç¨‹åˆ°è¾¾çš„æ—¶é—´ä¸æ˜¯ç›¸åŒçš„
                    Thread.sleep(2000 + Thread.currentThread().getId());
                    System.out.println("Thread_" + Thread.currentThread().getId() + "ç¡çœ ä¸¤ç§’åå¼€å§‹");
                }
                
                System.out.println(Thread.currentThread().getId() + "å¼€å§‹ç­‰å¾…");
                //å½“5ä¸ªçº¿ç¨‹å…¨éƒ¨åˆ°è¾¾åå¼€å§‹è¿è¡Œ
                barrier.await();

                System.out.println("å±éšœæ‰“å¼€ï¼Œå½“å‰Thread_" + Thread.currentThread().getId() + "å®Œæˆå…¶ä»–ä¸šåŠ¡é€»è¾‘");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

## å››ã€Exchanger

### 1.ä»€ä¹ˆæ˜¯Exchangerï¼Ÿ

Exchangerç”¨äºä¸¤ä¸ªçº¿ç¨‹é—´äº¤æ¢æ•°æ®ï¼Œå…¶ä¸­`exchange()`æ˜¯é˜»å¡å¼çš„ï¼Œå½“å…¶ä»–çº¿ç¨‹æ²¡æœ‰è°ƒç”¨è¯¥æ–¹æ³•äº¤æ¢åˆ™ä¸€ç›´é˜»å¡ï¼Œ`exchange()`çš„è¿”å›å€¼æ­£æ˜¯äº¤æ¢åˆ°çš„å†…å®¹

### 2.ç®€å•åº”ç”¨

```java
//ä¸¤ä¸ªçº¿ç¨‹é—´æ•°æ®äº¤æ¢
public class UseExchange {
    private static final Exchanger<Set<String>> EXCHANGER = new Exchanger<>();

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            @SneakyThrows
            public void run() {
                //å­˜æ”¾æ•°æ®çš„å®¹å™¨
                Set<String> setA = new HashSet<>();
                setA.add("firstçº¿ç¨‹1");
                setA.add("firstçº¿ç¨‹2");
                //äº¤æ¢set,å½“å¦ä¸€ä¸ªçº¿ç¨‹æ²¡æœ‰è°ƒç”¨exchangeæ—¶ï¼Œç¨‹åºåœ¨æ­¤å¤„é˜»å¡
                setA = EXCHANGER.exchange(setA);
                System.out.println("firsté˜»å¡å¼exchange");
                //äº¤æ¢åçš„æ•°æ®
                System.out.println("first:" + setA);
            }
        }).start();

        new Thread(() -> {
            Set<String> setB = new HashSet<>();
            setB.add("secondçº¿ç¨‹1");
            //setB.add("secondçº¿ç¨‹2");
            try {
                setB = EXCHANGER.exchange(setB);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("secondé˜»å¡å¼exchange");
            System.out.println("second:" + setB);
        }).start();
    }
}
```

## äº”ã€Semaphore

### 1.ä»€ä¹ˆæ˜¯Semaphoreï¼Ÿ

Semaphoreç¿»è¯‘æˆå­—é¢æ„æ€ä¸ºä¿¡å·é‡ï¼Œç”¨äº**æ§åˆ¶åŒæ—¶è®¿é—®æŸèµ„æºçš„çº¿ç¨‹æ•°é‡**ï¼ŒSemaphore ç±»ä¸­æ¯”è¾ƒé‡è¦çš„å‡ ä¸ªæ–¹æ³•å¦‚ä¸‹

* `public void acquire()`ï¼šé˜»å¡å¼è·å–ä¸€ä¸ªè®¸å¯
* `public void acquire(int permits)`ï¼šé˜»å¡å¼è·å–permitsä¸ªè®¸å¯
* `public void release()`ï¼šé‡Šæ”¾è®¸å¯ï¼Œæ³¨æ„é‡Šæ”¾è®¸å¯å‰å¿…é¡»å…ˆè·å¾—è®¸å¯
* `public void release(int permits)`ï¼šé‡Šæ”¾permitsä¸ªè®¸å¯

ä»¥ä¸Šå››ä¸ªæ–¹æ³•å‡æ˜¯é˜»å¡å¼çš„ï¼Œè‹¥æƒ³è¦ç«‹å³å¾—åˆ°æ‰§è¡Œç»“æœï¼Œå¯ä½¿ç”¨ä»¥ä¸‹å‡ ä¸ªæ–¹æ³•

* `public boolean tryAcquire()`ï¼šå°è¯•è·å–ä¸€ä¸ªè®¸å¯ï¼Œè‹¥è·å–æˆåŠŸåˆ™ç«‹å³è¿”å›`true`ï¼Œè‹¥è·å–å¤±è´¥åˆ™ç«‹å³è¿”å›`false`
* `public boolean tryAcquire(long timeout, TimeUnit unit)`ï¼šå°è¯•è·å–ä¸€ä¸ªè®¸å¯ï¼Œè‹¥åœ¨æŒ‡å®šçš„æ—¶é—´å†…è·å–æˆåŠŸåˆ™ç«‹å³è¿”å›`true`ï¼Œå¦åˆ™åˆ™ç«‹å³è¿”å›`false`
* `public boolean tryAcquire(int permits)`:å°è¯•è·å–permitsä¸ªè®¸å¯ï¼Œè‹¥è·å–æˆåŠŸåˆ™ç«‹å³è¿”å›`true`ï¼Œè‹¥è·å–å¤±è´¥åˆ™ç«‹å³è¿”å›`false`
* `public boolean tryAcquire(int permits, long timeout, TimeUnit unit)`ï¼šå°è¯•è·å–permitsä¸ªè®¸å¯ï¼Œè‹¥åœ¨æŒ‡å®šçš„æ—¶é—´å†…è·å–æˆåŠŸåˆ™ç«‹å³è¿”å›`true`ï¼Œå¦åˆ™åˆ™ç«‹å³è¿”å›`false`


å¯é€šè¿‡`availablePermits()`è·å–å¯ä»¥è®¸å¯æ•°ç›®

### 2.ç®€å•åº”ç”¨

#### 2.1.å·¥äººä¸æœºå™¨

è‹¥å·¥å‚æœ‰5å°æœºå™¨ï¼Œä½†æ˜¯æœ‰8ä¸ªå·¥äººï¼Œä¸€å°æœºå™¨åŒæ—¶åªèƒ½è¢«ä¸€ä¸ªå·¥äººä½¿ç”¨ï¼Œåªæœ‰ä½¿ç”¨å®Œå…¶ä»–å·¥äººæ‰èƒ½ç»§ç»­ä½¿ç”¨ï¼Œé‚£ä¹ˆå¯é€šè¿‡Semaphoreæ¥å®ç°

```java
int N = 8; //å·¥äººæ•°
Semaphore semaphore = new Semaphore(5); //æœºå™¨æ•°ç›®
for (int i = 0; i < N; i++)
	new Worker(i, semaphore).start();
}

static class Worker extends Thread {
    private int num;
    private Semaphore semaphore;

    public Worker(int num, Semaphore semaphore) {
        this.num = num;
        this.semaphore = semaphore;
    }

    @Override
    public void run() {
        try {
            semaphore.acquire();
            System.out.println("å·¥äºº" + this.num + "å ç”¨ä¸€ä¸ªæœºå™¨åœ¨ç”Ÿäº§...");
            Thread.sleep(2000);
            System.out.println("å·¥äºº" + this.num + "é‡Šæ”¾å‡ºæœºå™¨");
            semaphore.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

#### 2.2.é™åˆ¶DBè¿æ¥æ•°é‡

â‘ **SqlConnectImpl**æ•°æ®åº“è¿æ¥å®ç°ï¼Œå¤åˆ¶è·‘è·¯ï¼Œä»–ä¸é‡è¦ğŸ˜€

```java
import java.sql.*;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

public class SqlConnectImpl implements Connection {

    //è·å–æ•°æ®åº“è¿æ¥
    public static final Connection fetchConnection() {
        return new SqlConnectImpl();
    }

    @Override
    public Statement createStatement() throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql) throws SQLException {
        return null;
    }

    @Override
    public String nativeSQL(String sql) throws SQLException {
        return null;
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {

    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return false;
    }

    @Override
    public void commit() throws SQLException {

    }

    @Override
    public void rollback() throws SQLException {

    }

    @Override
    public void close() throws SQLException {

    }

    @Override
    public boolean isClosed() throws SQLException {
        return false;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        return null;
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {

    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return false;
    }

    @Override
    public void setCatalog(String catalog) throws SQLException {

    }

    @Override
    public String getCatalog() throws SQLException {
        return null;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {

    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return 0;
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public Map<String, Class<?>> getTypeMap() throws SQLException {
        return null;
    }

    @Override
    public void setTypeMap(Map<String, Class<?>> map) throws SQLException {

    }

    @Override
    public void setHoldability(int holdability) throws SQLException {

    }

    @Override
    public int getHoldability() throws SQLException {
        return 0;
    }

    @Override
    public Savepoint setSavepoint() throws SQLException {
        return null;
    }

    @Override
    public Savepoint setSavepoint(String name) throws SQLException {
        return null;
    }

    @Override
    public void rollback(Savepoint savepoint) throws SQLException {

    }

    @Override
    public void releaseSavepoint(Savepoint savepoint) throws SQLException {

    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return null;
    }

    @Override
    public Clob createClob() throws SQLException {
        return null;
    }

    @Override
    public Blob createBlob() throws SQLException {
        return null;
    }

    @Override
    public NClob createNClob() throws SQLException {
        return null;
    }

    @Override
    public SQLXML createSQLXML() throws SQLException {
        return null;
    }

    @Override
    public boolean isValid(int timeout) throws SQLException {
        return false;
    }

    @Override
    public void setClientInfo(String name, String value) throws SQLClientInfoException {

    }

    @Override
    public void setClientInfo(Properties properties) throws SQLClientInfoException {

    }

    @Override
    public String getClientInfo(String name) throws SQLException {
        return null;
    }

    @Override
    public Properties getClientInfo() throws SQLException {
        return null;
    }

    @Override
    public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        return null;
    }

    @Override
    public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        return null;
    }

    @Override
    public void setSchema(String schema) throws SQLException {

    }

    @Override
    public String getSchema() throws SQLException {
        return null;
    }

    @Override
    public void abort(Executor executor) throws SQLException {

    }

    @Override
    public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {

    }

    @Override
    public int getNetworkTimeout() throws SQLException {
        return 0;
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return false;
    }
}
```

â‘¡**DBPoolSemaphore**

```java
import java.sql.Connection;
import java.util.LinkedList;
import java.util.concurrent.Semaphore;

/**
 * Semaphoreä½¿ç”¨ï¼Œæ•°æ®åº“è¿æ¥æ± çš„å®ç°
 */
public class DBPoolSemaphore {
    //å¯ç”¨æ•°æ®åº“è¿æ¥åªæœ‰10ä¸ª(10ä¸ªconnection)
    private final static int POOL_SIZE = 10;

    //å¯ç”¨æ•°æ®åº“è¿æ¥æ•°
    private final Semaphore useful;
    //ä¸å¯ç”¨æ•°æ®åº“è¿æ¥æ•°
    private final Semaphore useless;

    public DBPoolSemaphore() {
        //åˆå§‹åŒ–
        this.useful = new Semaphore(POOL_SIZE);
        this.useless = new Semaphore(0);
    }

    //å­˜å‚¨æ•°æ®åº“è¿æ¥çš„å®¹å™¨
    private static LinkedList<Connection> pool = new LinkedList<>();

    static {
        //åˆ›å»º10ä¸ªconnectionå­˜åˆ°å®¹å™¨æ± ä¸­
        for (int i = 0; i < POOL_SIZE; i++) {
            pool.addLast(SqlConnectImpl.fetchConnection());
        }
    }

    //ä»è¿æ¥æ± è·å–é“¾æ¥
    public Connection takeConnect() throws InterruptedException {
        //å¯ç”¨è¿æ¥æ•°-1
        useful.acquire();
        Connection conn;
        synchronized (pool) {
            //è¿æ¥æ± ä¸­åˆ é™¤ä¸€ä¸ªè¿æ¥
            conn = pool.removeFirst();
        }
        //ä¸å¯ç”¨è¿æ¥æ•°+1
        useless.release();
        return conn;
    }

    //å½’è¿˜è¿æ¥
    public void returnConnect(Connection conn) throws InterruptedException {
        if (conn != null) {
            System.out.println("ç­‰å¾…çº¿ç¨‹æ•°ï¼š" + useful.getQueueLength() + "    å¯ç”¨è¿æ¥æ•°ï¼š" + useful.availablePermits());
            //ä¸å¯ç”¨è¿æ¥æ•°-1
            useless.acquire();
            synchronized (pool) {
                //å°†è¿æ¥æ•°æ·»åŠ å›æ¥
                pool.addLast(conn);
            }
            //å¯ç”¨è¿æ¥æ•°+1
            useful.release();
        }
    }
}
```

â‘¢**Test**

```java
import lombok.SneakyThrows;
import java.sql.Connection;
import java.util.Random;

public class Test {
    private static DBPoolSemaphore dbPool = new DBPoolSemaphore();

    //ä¸šåŠ¡çº¿ç¨‹
    private static class TestThread extends Thread {
        @SneakyThrows
        @Override
        public void run() {
            //ä½¿æ¯ä¸ªçº¿ç¨‹çš„è¿æ¥æ—¶é—´ä¸åŒ
            Random random = new Random();
            long start = System.currentTimeMillis();

            //ä»è¿æ¥æ± æ‹¿è¿æ¥
            Connection conn = dbPool.takeConnect();
            System.out.println("thread_" + Thread.currentThread().getId() + "è·å–æ•°æ®åº“è¿æ¥è€—æ—¶ï¼š" + (System.currentTimeMillis() - start));

            //æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ(çº¿ç¨‹æŒæœ‰è¿æ¥è¿›è¡ŒæŸ¥è¯¢æ“ä½œæ¶ˆè€—ä¸€å®šæ—¶é—´)
            Thread.sleep(100 + random.nextInt(100));

            //ä¸šåŠ¡å¤„ç†å®Œæ¯•ï¼Œå½’è¿˜è¿æ¥
            dbPool.returnConnect(conn);
        }
    }

    public static void main(String[] args) {
        //åˆ›å»º50ä¸ªè¯·æ±‚çº¿ç¨‹
        for (int i = 0; i < 50; i++) {
            Thread thread = new TestThread();
            thread.start();
        }
    }
}
```





