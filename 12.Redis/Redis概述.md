# Redis概述

## 一、Redis简单介绍

### 1.Redis是什么?

Redis是高性能、K-V、**非关系型**、**缓存**数据库，C语言编写

* 基于内存、同时支持缓存

Redis的操作是**原子操作**

### 2.Redis的版本介绍

* 版本号第二位为**奇数**是**非稳定版**

- 版本号第二位为**偶数**是**稳定版**

### 3.Redis支持的数据类型及特性

**String**：支持字符串、整性、浮点型、二进制操作，可自增自减

* 适用于存共享Session、分布式锁、计数器、限流

**List**：列表，可模拟堆栈等数据结构

* 适用于存粉丝列表、点赞列表、评论列表

**Set**：无序且唯一

* 适用于存用户标签、随机抽奖等去重场景

**ZSet**：有序且唯一

* 适用于存排行榜、寻找Top

**Hash**：K-V

* 适用于存用户信息

### 4.Redis应用场景

#### 4.1.缓存

合理的利用缓存，比如缓存热点数据，不仅可以提升网站的访问速度，还可以降低数据库DB的压力
并且Redis提供持久化机制与多种数据结构，强的一批

#### 4.2.排行榜

Redis提供**ZSset**数据类型能实现复杂的排行榜，比如用户每天上传视频，获得点赞的排行榜可以这样设计

> 用户Jay上传一个视频获得6个赞：`zadd user:ranking:2021-03-03 Jay 6`
> 过了一段时间再获得一个赞：`zincrby user:ranking:2021-03-03 Jay 1`
> 如果某个用户John作弊，需要删除该用户：`zrem user:ranking:2021-03-03 John`
> 展示获取赞数最多的3个用户：`zrevrangebyrank user:ranking:2021-03-03 0 2`

#### 4.3.计数器

短视频的播放数、电商网站的浏览数都要用到计数器，这些数据一般要求都是**实时的**，如果并发量很大对于传统关系型数据的性能是一种挑战，Redis天然支持计数功能而且计数的性能也非常好，可以说是计数器系统的重要选择

#### 4.4.共享Session

分布式Web服务将用户的Session信息保存在各自服务器，用户刷新一次可能就需要重新登录，Redis将用户的Session进行集中管理，每次用户更新或者查询登录信息都直接从Redis中集中获取

#### 4.5.分布式锁

分布式服务下遇到对同一个资源的并发访问的技术难题，如秒杀、下单减库存等场景，用synchronize或者reentrantlock本地锁肯定是不行，并发量不大话使用数据库的悲观锁、乐观锁来实现没啥问题，但是在高并发场合中，利用数据库锁来控制资源的并发访问，会影响数据库的性能，实际上，可以用**Redis的setnx实现分布式锁**

#### 4.6.社交网络

赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型数据不太适保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能

#### 4.7.消息队列

消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，**主要用于业务解耦、流量削峰及异步处理实时性低的业务**，Redis提供发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统

#### 4.8.位操作

用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等，腾讯10亿用户，要几个毫秒内查询到某个用户是否在线，能怎么做？千万别说给每个用户建立一个Key，然后挨个记，可以**使用setbit、getbit、bitcount命令**，**原理是Redis内构建足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示用户id(必须是数字)，，显然这个几亿长的大数组就能通过下标和元素值(0和1)来构建一个记忆系统**

## 二、Redis为什么快？

### 1.基于内存

Redis基于内存，目的是**减少磁盘IO**

### 2.单线程

Redis基于内存，所以CPU并不是Redis的性能瓶颈，**内存大小和网络IO(网络带宽)**才是，且单线程容易实现，所以采取单线程，有效避免多线程下加锁带来的开销与系列问题，如死锁、上下文切换等

Redis6.0后采取多线程，但也不是完全摒弃单线程，处理客户端读写与协议解析通过多线程处理，执行客户端命令还是单线程，使用多线程可以提升IO读写效率

### 3.IO多路复用

多路指多个Client连接Redis，复用指单线程处理请求，**有效提高系统吞吐量**

多路复用主要有select、poll、epoll等三种技术，过程大概是将Client请求放入队列中，Redis循环从队列中取出请求处理

### 4.虚拟内存

将冷数据存于磁盘，为热数据腾出更多空间，通过虚拟内存可实现**冷热数据分离**，避免因内存不足而造成访问速度下降

### 5.高效的数据结构

Redis支持的各种数据类型的底层数据结构如下图

![1657452978786](assets/1657452978786.png)

**动态字符串**内部存储使用SDS封装，SDS结构如下图

![1657453124090](assets/1657453124090.png)

**字典**实际就是哈希表，通过Key快速找到Value，时间复杂度O(1)

**跳跃表**实际就是在链表基础上多加几级索引，提升查找效率

![1657453306172](assets/1657453306172.png)

### 6.合适的数据编码

**String**：数字用int，非数字小于等于39字节字符串使用embstr，大于39个字节使用raw

**List**：列表元素个数小于512，且列表每个元素的值都小于64字节(默认)，使用ziplist编码，否则使用linkedlist编码

**Hash**：哈希类型元素个数小于512个，且每个值小于64字节，使用ziplist编码，否则使用hashtable编码

**Set**：集合元素都是整数,且元素个数小于512个，使用intset编码，否则使用hashtable编码

**ZSet**：有序集合的元素个数小于128，且每个元素的值小于64字节，使用ziplist编码，否则使用skiplist

## 三、缓存穿透、缓存雪崩、缓存击穿

### 1.缓存穿透

常见缓存方式是当请求发来时，先经过缓存，在缓存中查，当缓存未命中则去数据库查，数据库有则将值更新到缓存后再返回

缓存穿透指查不存在的值时，每次都需要查数据库，给数据库带来压力，即**请求穿透到数据库**

缓存穿透一般发生于业务设计不合理、运维或开发人员事务、黑客恶意攻击等场景

缓存穿透可直接在API处对参数进行校验，过滤非法请求的方式避免，也可通过**布隆过滤器**避免

### 2.缓存雪崩

缓存雪崩指大量数据到达过期时间，且查询量巨大，给数据库带来压力

缓存雪崩可通过均匀设置过期时间，使过期时间相对离散有效解决，如较大固定值+较小的随机值(5h+0-1800s)，Redis宕机使整个Redis不可用也会导致缓存雪崩，可通过构造Redis高可用集群解决

### 3.缓存击穿

缓存击穿指热点Key到达过期时间，恰好此时对该热点Key发来大量请求，给数据库带来压力

缓存击穿可通过互斥锁或永不过期(异步更新过期时间)解决

## 四、布隆过滤器

### 1.什么是布隆过滤器？

布隆过滤器是一种占极小空间的数据结构，由一个超长二进制数组和多个Hash函数组成，用于检索数据是否存在，其占空间小且查询时间短，但存在误识别的情况(Hash冲突)且删除困难

### 2.布隆过滤器的原理

假设集合A中有n个元素，利用k个哈希散列函数，将A中的每个元素映射到一个长度为a位的数组B中的不同位置上，这些位置上的二进制数均设置为1

如果待检查的元素经过这k个哈希散列函数的映射后，发现其k个位置上的二进制数全部为1，这个元素很可能属于集合A，反之一定不属于集合A

### 3.布隆过滤器的实现过程

假设集合A有3个元素，分别为{d1,d2,d3}，有1个哈希函数为Hash1，现在将A的每个元素映射到长度为16位数组B

![1657455769690](assets/1657455769690.png)

映射d1，假设Hash1(d1)= 2，则数组B中下标为2的格子改成1

![1657455790055](assets/1657455790055.png)

映射d2，假设Hash1(d2)= 5，则数组B中下标为5的格子改成1

![1657455808299](assets/1657455808299.png)

映射d3，假设Hash1(d3)= 2，则也将数组B中下标为2的格子改成1

![1657455835977](assets/1657455835977.png)

确认元素dn是否在集合A里，只要算出Hash1(dn)得到索引，索引对应元素是0则该元素不在集合A，如果索引下标是1也只能表示该元素**可能**是A中的某一个元素，因为d1和d3得到的下标值都可能是1，所以布隆过滤器是存在Hash碰撞导致假阳性，判断存在误差的缺点

如何减少这种误差？**多搞几个哈希函数映射**，降低哈希碰撞的概率；同时**增加二进制数组的bit长度**，可以增大Hash函数生成的数据的范围，也可以降低哈希碰撞的概率

又增加一个Hash2哈希映射函数，假设Hash2(d1)=6，Hash2(d3)=8，使d1和d3不冲突

![1657455996049](assets/1657455996049.png)

布隆过滤器并没有存放完整的数据，只是运用一系列哈希映射函数计算出位置，然后填充二进制向量，**如果数量很大的话，布隆过滤器通过极少的错误率，换取了存储空间的极大节省**

## 五、热点Key问题

### 1.什么是热点Key？

热点Key顾名思义是访问频率高的Key

若热点Key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务

热点Key产生于秒杀，热点新闻等场景，或者请求分片集中，超过单台Redis服务器的性能

### 2.如何解决热点Key问题？

热点Key可通过**将热点Key副本分布于Redis集群，然后负载均衡请求**解决，也可通过**将热点Key本身分布于Redis集群**解决

## 六、Redis过期键删除策略

### 1.删除策略有哪些？

**定时删除**：设置键过期时间

**惰性删除**：放任键过期不管，每次查键时，先检查键是否过期，若过期则删除该键，若未过期则取出该键

**定期删除**：每隔一段时间检查键是否过期，删除过期的键

### 2.Redis采取哪些删除策略？

Redis采取**定期删除策略**，每隔一段时间随机抽取一定数量的Key检查是否过期，由于Key是随机抽取的，可能导致最后还是有大量过期Key没有删除，所以Redis同时采取**惰性删除策略**，每次取键前都检查键是否过期，但这样仍然可能存在过期键没有删除干净的情况，过期键一直不删除则一直存于内存中，随着业务量加大，可能导致内存爆满，此时Redis当然不会放任这些过期键不管，采用**内存淘汰策略**淘汰遗留下来的过期键

> Redis的定期删除策略为什么选择抽取部分Key检查是否过期，而不是所有？
>
> 若Redis中存储30万个键，每隔一段时间就要遍历每30万个键检查是否过期，导致CPU负载则别高，最后可能会宕机

### 3.Redis的内存淘汰机制有哪几种？

allkeys-lru：当内存不足以容纳新写入的数据时，从**所有的键中采取最近最少使用算法**淘汰

volatile-lru：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中采取最近最少使用算法**淘汰

allkeys-lfu：当内存不足以容纳新写入的数据时，从**所有的键中采取最不经常使用算法**淘汰

volatile-lfu：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中采取最不经常使用算法**淘汰

> lru是淘汰**最长时间**没有使用的，lfu是淘汰一段时间内**使用次数**最少的

allkeys-random：当内存不足以容纳新写入的数据时，从**所有的键中随机**淘汰

volatile-random：当内存不足以容纳新写入的数据时，从**设置了过期时间的键中随机**淘汰

allkeys-ttl：当内存不足以容纳新写入的数据时，从**所有的键中采取最接近过期时间算法**淘汰

nativation：当内存不足以容纳新写入的数据时，新写入操作会**报错**

## 七、Redis的持久化机制

### 1.持久化加载流程

**Redis基于内存，为了避免数据丢失则将数据保存到磁盘**

![1657625007688](assets/1657625007688.png)

### 2.RDB

**RDB指每隔一段时间将内存中的数据以快照的形式存于硬盘(dump.rdb)**，由于RDB操作有时间间隔，可能存在数据丢失的情况，数据安全性低，无法做到秒级持久化

RDB的触发机制有三种，save(阻塞式)、bgsave(异步式)、save m n(m秒内数据集存在N次修改触发bgsave)

> Redis生成RDB期间还可以处理读写请求吗？
>
> save触发RDB是阻塞式的，主线程运行处理Redis读写请求，bgsave触发RDB是异步式的，使用子进程生成RDB，父进程处理Redis读写请求

### 3.AOF

**AOF指将每次的写命令记录到单独的日志文件中**，每次重启Redis时会重新使用持久化日志文件恢复数据，随着时间的推移启动会越来越慢，默认关闭，AOF的工作流程如下图

![1657626392685](assets/1657626392685.png)

通过append的方式向AOF缓冲器写写命令，这样即使Redis中途宕机也可通过redis-check-aof工具保证数据的一致性

## 八、Redis高可用

### 1.配置高可用的目的

**高可用可防止单点故障，避免整个集群不可用**

### 2.Redis实现高可用的三种部署模式

#### 2.1.主从模式

主节点负责**读写操作**，从节点只负责**读操作**，且从节点的数据都来自主节点，实现原理叫**主从复制**，主从复制包括**全量复制和增量复制**

当Slave第一次启动连接Master会认为是第一次连接，采用全量复制

![1657718636345](assets/1657718636345.png)



#### 2.2.哨兵模式

#### 2.3.Cluster集群模式

