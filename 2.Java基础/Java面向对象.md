# Java面向对象

## 一、什么是面向对象？

面向对象的思想更符合我们的思维习惯，将复杂的事情简单化，使我们从执行者变为了指挥者

面向对象思想基于面向过程的思想，二者区别在于处理问题的方式不同

* **面向过程是将解决问题的过程拆成方法，执行每个方法解决问题**，例如我去买饭，可将出门、买饭、回来设计成三个方法，只需调用三个方法即可买到饭
* **面向对象强调的是对象，由对象去调用方法**，例如我去买饭可以不用亲自去，让同学带饭呀！我只需要等饭，怎么带饭是同学的事情，同学怎么买饭就是面向过程，而我等待的过程就是面向对象

面向对象开发实际就是不断的创建对象，使用对象，指挥对象办事，我们主要做的就是管理和维护对象间的关系

面向对象存在三大特性，现在不理解没关系，先往后学习，学习完了之后在回过头

* **封装**(encapsulation)：将对象的状态信息隐藏于对象内部，不允许外部对象直接访问对象内部信息
* **继承**(inherritance)：子类拥有父类所以属性和方法，但对于私有方法只是拥有，不能访问
* **多态**(polymorphism)：父类引用指向父类对象，若子类重写父类方法则使用子，否则使用父

## 二、类和对象

### 1.什么是类和对象？

类是Java中最基本的单位，是对对象共同特征的描述，一组**属性和行为集合**，是一个抽象的概念，比如鸟类

* 属性：该事物的描述信息
* 行为：该事物能够做什么

对象是该类事物的具体表现形式，是真实存在的东西，是一个具体的概念，比如鸟类中的麻雀，你一定听说过**万物皆对象**吧

在Java中，**必须先设计类才能获得对象**

![1662102292849](assets\1662102292849.png)

### 2.定义类和得到对象

#### 2.1.如何定义类？

定义类的格式如下

![1662102785442](assets\1662102785442.png)

类名建议首字母大写，且见名知义

**一个Java文件中可定义多个类，但是只能存在一个`public`修饰的类，且`public`修饰的类的类名需和文件名相同**，实际开发过程中建议一个Java文件只写一个类

#### 2.2.如何得到类的对象？

得到类的对象的格式如下

![1662102848608](assets\1662102848608.png)

**`new`时创建对象，创建对象的过程也是实例化的过程**，实例化时会初始化类的成员

引用表示等号左边的部分，实例表示等号右边的部分，其中**一个引用只能指向零个或一个实例，而一个实例可有多个引用**

## 三、类详解

上面呢讲了讲什么是类，以及类的定义方式，其实类的相关知识中还有许多细节部分，接下来就让我我详细的讲一讲！

### 1.成员变量

成员变量的完整定义格式是`修饰符 数据类型 变量名 = 初始化值;`，一般无需指定初始值，存在默认值，默认值规则如下

![1662103859430](assets\1662103859430.png)

成员变量通过对象的使用格式是`对象名.变量名 = 值;`

方法中的局部变量和类中的成员变量的名称可以相同，调用时就采取**就近原则**

* 什么是局部变量？什么是成员变量？

  ![1662349009426](assets\1662349009426.png)

* 成员变量和局部变量的区别如下

|      区别      |                  成员变量                  |                    局部变量                    |
| :------------: | :----------------------------------------: | :--------------------------------------------: |
|  类中位置不同  |             类中且方法外的变量             |                  方法中的变量                  |
| 内存中位置不同 |                     堆                     |                       栈                       |
|  生命周期不同  | 随着对象的创建而存在，随着对象的消失而消失 | 随着方法的调用而存在，随着方法的调用完毕而消失 |
|  初始化值不同  |                  有默认值                  |            无默认值，使用前需要赋值            |

### 2.封装

#### 2.1.作用

封装是面向对象的三大特征之一，**封装告诉我们拿到一个需求以后该如何设计类的属性和方法**，即**对象代表什么，就要封装对应的属性，并提供属性相关的动作**，例如人画圆，涉及到人对象的圆对象，圆对象存在半径属性，那么画圆这个动作到底是属于人对象还是圆对象呢？再体会一次加粗字体的那句话，不难得出画圆需要根据半径画，那么画圆就是属性半径的相关动作，所以画圆这个动作应该是属于圆对象的

![1662104849711](assets\1662104849711.png)

#### 2.2.修饰符private

`private`是一个关键字，是一个限权修饰符，可以修饰成员变量和成员方法，**被`private`修饰的成员只能在本类中才能访问，外界不可直接访问**，这样做既隐藏实现细节，提高安全性，又提高代码的复用性 

`private`常见的应用是所有的属性用`private`修饰，对外提供`public`的`getXXX()`、`setXXX(参数)`用于对私有属性取值和赋值

```java
private String name;
public void setName(String n){
    name = n;
}
public String getName(){
    return name;
}
```

### 3.关键字this

`this`代表当前所在类的对象引用，理解为`this`就是当前类的一个对象，**被哪个对象调用，`this`就代表那个对象**

在成员变量的学习过程中，我们了解到方法中的局部变量和类中的成员变量的名称可以相同，调用时就采取**就近原则**，但究竟啥是就近？

* 就近，顾名思义就是谁离我近就是谁呗！

  ![1662349122037](assets\1662349122037.png)

* 若我想打破就近原则，就想使用成员位置的属性怎么办呢？我们想到调用格式是`对象名.属性名`，那么此时对象是不可知的，那么想到刚刚学习的`this`关键字不就代表当前类的对象引用嘛！

  ![1662349323617](assets\1662349323617.png)

综上，`this`常用于局部变量隐藏成员变量的场景，若没有`this`关键字则采用就近原则

有了`this`关键字以后，`getXXX()`、`setXXX(参数)`方法的格式也稍作改变

```java
private String name;
public void setName(String name){
    this.name = name;
}
public String getName(){
    return name;
}
```

------

从内存的角度理解`this`关键字

![1662359944740](assets\1662359944740.png)

### 4.构造方法

构造方法又叫构造器、构造函数，用于**在创建对象时给成员变量进行初始化**，初始化简单理解为赋值

构造方法的定义格式如下，其中**构造方法名必须与类名相同**、**无返回值类型，连`void`都没有**、**没有具体的返回值，即不能由`return`带回具体的返回值，`return;`可以有**

![1662349831378](assets\1662349831378.png)

构造方法的参数可有可无，根据需要，**构造方法可以重载，但不能重写**

![1662350091637](assets\1662350091637.png)

**若不提供构造方法，系统会默认给出无参构造方法；若提供了构造方法，系统将不再提供无参构造方法**

**创建对象(new)时由虚拟机自动调用构造函数**，不能手动调用；**每创建一次对象就调用一次构造方法**

> 最佳实践：无参构造、带所有属性的构造、每个属性提供`set`和

### 5.标准JavaBean

前面讲了这么多，那么一个标准的JavaBean是怎样的呢？

* 类名见名知义
* 成员变量使用`private`修饰
* 至少提供两个构造，即无参和带全部参的构造
* 为每个成员变量提供`set`和`get`函数
* 成员变量相关行为也要附上

IDEA中存在快速生成构造与`get`、`set`的方式，即`Alt+Ins`

![1662356404864](assets\1662356404864.png)

### 6.修饰符static

#### 6.1.引入

当存在一个学生类，其中属性包括姓名、年龄，一切都那么正常

```java
class Student{
    private String name;
    private int age;
    
    public Student(){}
    
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
    
    public void setAge(String age){
        this.age = age;
    }
    public String getAge(){
        return age;
    }
    
    public vois show(){
        System.out.println(name+"-"+age);
    }
}
```

```java
class StudentTest{
    public static void main(String[] arge){
        Student s1 = new Student();
        s1.setName("张三");
        s1.setAge(18);
        
        s1.show();
        
        Student s2 = new Student();
        s2.setName("李四");
        s2.setAge(18);
        
        s1.show();
        
        Student s3 = new Student();
        s3.setName("王五");
        s3.setAge(18);
        
        s3.show();
    }
}
```

若给学生类增加一个老师的属性，那么一个班级每个学生的老师都是相同的，难道需要在每一个学生对象创建时使用`setTeacher()`赋值嘛？答案是否定的，可以使用`static`修饰老师这个属性，使老师属性被所有的学生对象共享

```java
class Student{
    private String name;
    private int age;
    public static String teacher;
    
    public Student(){}
    
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
    
    public void setAge(String age){
        this.age = age;
    }
    public String getAge(){
        return age;
    }
    
    public vois show(){
        System.out.println(name+"-"+age+"-"+teacher);
    }
}
```

```java
class StudentTest{
    public static void main(String[] arge){
        Student.teacher = "陈老师";
            
        Student s1 = new Student();
        s1.setName("张三");
        s1.setAge(18);
        
        s1.show();
        
        Student s2 = new Student();
        s2.setName("李四");
        s2.setAge(18);
        
        s1.show();
        
        Student s3 = new Student();
        s3.setName("王五");
        s3.setAge(18);
        
        s3.show();
    }
}
```

#### 6.2.概述

`static`表示静态，可以修饰成员方法、成员变量，**被`static`修饰的成员被该类所有的对象共享**

访问可通过普通的对象去调用，语法上不会存在什么问题，但在语义上，**静态成员被所有的该类对象共享，所以静态成员不再属于某个对象，而是属于类**，推荐使用类名调用，格式是`类名.静态成员`

**静态成员随着类的加载而加载，随着类的消失而消失，优先于对象存在，生命周期伴随整个程序**

程序运行的时候`static`修饰的成员就被加载，而不被修饰的成员创建对象时才会加载

#### 6.3.内存图解

![1662361984354](assets\1662361984354.png)

#### 6.4.静态变量

静态变量和成员变量的区别如下

|      区别      |                静态变量                |                  成员变量                  |
| :------------: | :------------------------------------: | :----------------------------------------: |
| 内存中位置不同 |             方法区的静态区             |                     堆                     |
|  生命周期不同  | 随着类的加载而加载，随着类的消失而消失 | 随着对象的创建而存在，随着对象的消失而消失 |
|    所属不同    |        属于类，所以也称为类变量        |        属于对象，所以也称为对象变量        |
|    调用不同    |  可以通过类名调用，也可以通过对象调用  |             只能通过对象名调用             |
|  访问限制不同  |            只可访问静态成员            |              可以访问所有成员              |

#### 6.5.静态方法

静态方法同样是随着类的加载而加载，关于静态方法请注意一下几点

* **静态方法只能访问静态成员**，因为非静态成员不存在时静态方法就已经存在，访问不存在的成员属于非法调用
* 非静态方法可以访问静态成员，但**不能定义静态局部变量**，前面也说过`static`只能修饰成员变量或成员方法
* **静态方法中不可存在`this`关键字**，因为`this`指向当前类的对象，随着对象的创建而存在，而静态方法随着类的加载而加载，静态成员优先于对象存在

#### 6.6.重新认识main方法

![1662363150388](assets\1662363150388.png)

### 7.继承

#### 7.1.引入

之前学习过封装，封装就是对象代表什么就要封装相应的数据和数据对应的行为

![1662364566183](assets\1662364566183.png)

但是当这样的JavaBean类越来越多时，就会存在问题，重复的代码太多，浪费空间

![1662364623747](assets\1662364623747.png)

问题出现了，那么请解决吧！通过类和类之间的继承关系可以解决的，儿子可以继承爸爸的财产

![1662364707540](assets\1662364707540.png)

#### 7.2.概述

Java中使用`extends`关键字建立类之间的继承关系，体现的是`is a`的关系，格式如下

![1662364868012](assets\1662364868012.png)

继承的好处

* 将子类的重复代码抽取到父类中，提高代码复用性
* 若出现问题只需修改父类，提高代码可维护性
* 子类可在父类基础上增加其他功能，使子类更加强大
* 类之间的继承关系也是多态的前提

继承的坏处

* 继承使类之间产生了联系，使类之间的耦合性增强，增加后期维护的难度
  * 开发原则之一是低耦合，高内聚，耦合指的是类与类之间的关系

* 继承打破Java的封装性

#### 7.3.何时使用继承？

当类与类之间存在共性，并满足子类是父类的一种，则可以使用继承来优化代码

![1662366009781](assets\1662366009781.png)

#### 7.4.特点

Java只**支持单继承**，不支持多继承，但**支持多层继承**，且继承的单方向的，子可以访问父，但父不能访问子

* 单继承：一个儿子只能有一个爸爸，C++支持多继承

* 多层继承：爸爸可以有自己的爸爸

  ```java
  class A{}
  class B extends A{}
  class C extends B{}
  ```

每个类都直接或间接的继承于`Object`

#### 7.5.子类继承哪些内容？

在你的理解中可能存在父类私有的东西子类无法继承，父类非私有的东西都被子类继承的误区，事实真的会这样嘛？接下来从三个角度学习

* 构造方法是否可以被继承？不能被继承，但可以通过`super`关键字访问

  ![1662368271363](assets\1662368271363.png)

* 成员变量是否可以被继承？私有非私有成员变量能被继承，只是私有的成员变量不能被使用

  ![1662369199027](assets\1662369199027.png)

  ![1662369506667](assets\1662369506667.png)

* 成员方法是否可以被继承？虚方法表中的方法可以被继承，虚方法指非`private`、`final`、`static`修饰的方法

  ![1662369865594](assets\1662369865594.png)

  ![1662370099663](assets\1662370099663.png)

小结一波

![1662370127002](assets\1662370127002.png)

#### 7.6.访问特点

①继承中成员变量的访问特点

继承中成员变量名相同时，使用**就近原则**，即先在子类方法的局部范围找，然后在子类成员范围找，最后在父类成员范围找，最终没有就报错

![1662370931628](assets\1662370931628.png)![1662370945476](assets\1662370945476.png)![1662370954835](assets\1662370954835.png)

若想要突破就近原则，怎么办？之前已经学习过`this`关键字，此处的`super`关键字指父类，可以操作父类的成员，调用父类构造函数

![1662371216680](assets\1662371216680.png)

------

②继承中成员方法的访问特点

同样的，满足就近原则，可使用关键字去调用，此处再扩充**重写**的相关知识

当父类方法无法再满足子类要求时，需要子类重写父类的方法，**在继承中子类出现和父类中一模一样的方法声明，则称为重写**，重写的特点是**两同、两小、一大**

* 两同指方法名相同、参数列表相同
* 两小指子类返回值类型小于等于父类、抛出的异常小于等于父类
* 一大值子类访问权限修饰符大于等于父类

重写方法的本质就是覆盖虚方法表中的方法

![1662372279948](assets\1662372279948.png)

重写中注意**父的私有方法不能被重写**，父的私有方法都不能被继承，怎么重写呢！虚方法表中都没有私有方法，怎么找得到呢！

子类重写的方法上加上注释`@Override`，注释是提醒虚拟机的，告诉虚拟机这是个重写方法，若不满足重写规范虚拟机将给出语法错误提示

------

③继承中构造方法的访问特点

在7.5中我们学习到父类的构造方法是不能被继承的，**当创建子类对象时会先创建父类对象，再完成创建子类对象**，即子类构造方法默认先访问父类的无参构造，再执行自己的，**若父类对象创建失败，则无法创建子类对象**

为什么要先访问父类的无参构造呢？因为子类在初始化时可能会用到父类的数据，若父类未初始化则无法使用父类的数据

子类构造方法是如何调用父类无参构造的？**子类构造方法第一行默认`super()`，不写虚拟机会为我们加上，若想要调用父类有参构造，则需要自己手动调用`super(参数...)`**

#### 7.7.this&super

`this`指的是当前类的一个对象，是一个地址值；`super`指的是父类存储空间，使用区别如下

![1662433258991](assets\1662433258991.png)

关于`this`和`super`关键字请注意

- `this`和`super`不可同时使用，用了`super`就不要再使用`this`
- `this()`和`super()`有则必须出现在构造函数的第一条语句上，且不能同时出现，否则会出现父类数据多次初始化的问题

若父类中没有无参构造方法，子类中的构造方法会报错，怎么解决？

- 方法一：在父类中添加无参构造方法
- 方法二：通过`super`关键字访问父类的有参构造方法
- 方法三：通过`this`关键字调用本类的构造方法

### 8.多态

#### 8.1.引入

现在有这样一个场景，某个系统中存在三个角色，分别是学生、老师、管理员，同时存在一个注册的方法，以角色对象作为参数，此时每个角色都需要一个相应的注册方法

![1662440725473](assets\1662440725473.png)

这样做当然是不好的，能用继承解决吗？这三个对象有许多属性是相同的，那么他们是可以抽离出同一个父类对象的，命名为`Person`，虽然抽离出了三个角色共同的父类，但我们的问题依然没有解决，那么可不可以将形参设置为他们的共同父类，传入的实参是具体的子类呢？答案是肯定的！这就是多态

![1662441181343](assets\1662441181343.png)

#### 8.2.概述

多态其实指的就是**对象的多种形态，即同类型对象表现出的不同形态**，创建形式是`父类名 对象名 = new 子类名()`

并不是所有情况下都能使用多态，**必须满足以下条件**

- **有继承关系或实现接口关系**
- **有子类对象指向父类引用**，即`Fu f = new Zi()`
- **有方法重写**

#### 8.3.调用特点

**成员变量**：编译看左边，运行看左边，意思是父类没有该成员变量则编译失败，实际使用的也是父类的成员变量

**成员方法**：编译看左边，**运行看右边**，意思是父类没有该成员方法则编译失败，实际使用的是子类的成员变量

**静态方法**：编译看左边，运行看左边，因为静态方法不存在于虚方法表中，不能被重写

请看下图的例子，若此时使用`Dog d = new Dog()`创建对象，则`d.name`会先在`Dog`中找，没有再去`Animal`中找，区别与`Animal a = new Dog()`创建对象的方式，`a.name`编译时若`Animal`中没有`name`属性，则编译失败，运行时也会使用`Animal`的

![1662442210040](assets\1662442210040.png)

在看一个内存图解

![1662449045661](assets\1662449045661.png)

#### 8.4.优势&弊端

多态的优势是方法中使用父类类型作为参数，可以接收所有的子类对象；弊端是不能使用子类特有的功能

#### 8.5.转型

多态实际就是一种自动类型提升，但是这样不能调用子类特有的方法，但是我现在就是要使用子类特有的方法怎么办？**强制类型转换**

```java
Parent p = new Son();
Son s = (Son)p;
```

注意`Son p = (Son)new Parent();`的转换方式是不行的，这不是多态的强转

强转内存图如下

![1662449923309](assets\1662449923309.png)


## 四、对象详解

上面呢讲了讲什么是对象，以及对象的定义方式，接下来就让我我详细的讲一讲！

### 1.内存图解

一个对象被`new`时至少会经历一下步骤，即`Student s = new Student()`

* 加载`class`文件到方法区中临时存储

  ![1662358539269](assets\1662358539269.png)

* 声明局部变量，即`Student s`

  ![1662358602104](assets\1662358602104.png)

* 在堆内存中开辟空间，即`new Student()`，该空间会拷贝所有的成员变量存储、还会存成员方法的地址

  ![1662358668017](assets\1662358668017.png)

* 成员变量默认初始化

  ![1662358719694](assets\1662358719694.png)

* 成员变量显示初始化

  ![1662358395182](assets\1662358395182.png)

* 构造方法初始化

* 将堆内存中的地址值赋值给左边的局部变量

   ![1662358903125](assets\1662358903125.png)

------

接下来就不一步一步拆解了！请看一下内存图解

* 一个对象

![1662356811119](assets\1662356811119.png)

* 两个对象

![1662356842633](assets\1662356842633.png)

* 三个对象

![1662356876017](assets\1662356876017.png)

> 视频讲解：[链接](https://www.bilibili.com/video/BV17F411T7Ao?p=91&vd_source=8811945bf338927db8b1ca45a8f75a87)

------

在Java入门的文章中我们学习到基本数据类型与引用数据类型，那么现在从内存角度进行理解

* **基本数据类型数值存于自己的空间**，赋值给其他变量也是赋予真实的值

  ![1662359681410](assets\1662359681410.png)

* **引用数据类型数值存于其他的空间**，自己的空间存储的是地址值，赋值给其他变量的是地址值

  ![1662359694227](assets\1662359694227.png)

### 2.匿名对象


概述：没有名字的对象，是一种简单化表现形式
格式：new 类名(…);
应用场景
1.调用类中方法且仅调用一次，调用多次时不合适
	new 类名().类中方法名();
2.可作为实际参数传递  
	对象名.对象中的方法(new 类名());
1
2
3
4
优点：调用完毕就是垃圾，可以被垃圾回收器回收
5.对象相等与引用相等的区别
对象相等：内存中的内容相等
引用相等：内存地址相等



## 五、细节知识补充

### 1.包

包就是文件夹，用于管理各种功能不同的Java类，方便后期代码维护，同时可以将同名的类放在不同的包下

包名的命名方式各个公司有自己的规范，我的命名习惯是`com.公司名.功能名`

有了包以后，每个类的第一行就需要加上`package`语句

![1662450463912](assets\1662450463912.png)

有了包以后，使用其他包中类的方式也就和之前不太一样了！有如下几种方式

- 使用全类名

  ![1662450820265](assets\1662450820265.png)

- **导包**：使用全类名方式非常麻烦

  ![1662450870246](assets\1662450870246.png)

以上我们知道了包和导包，关于这两个知识点还存在一下的**注意点**

- `package`语句必须是程序的第一条可执行代码，其次是`import`，最后写Java类
- `package`语句在一个Java文件中只能有一个，而`import`语句可以有多个，Java类也可以有多个，但建议一个
- 没有`package`表示无包名

### 2.关键字final

`final`意思是最终的，即不能改变，可以修饰方法、类和变量，**修饰内容不同特点不同**

- `final`修饰方法，则该方法不能被重写
- `final`修饰类，则该类不能被继承
- `final`修饰变量，则该变量不能被重新赋值，即为常量
  - 基本类型变量：变量的**数据值**不能发生改变
  - 引用类型变量：变量的**地址值**不能发生改变，对象内部属性值可以改变

`final`关键字修饰的变量在多线程环境下的安全的，因为只能被赋值一次

### 3.权限修饰符

权限修饰符用于控制某个成员能被访问的范围，存在四中，其访问范围如下

![1662452445511](assets\1662452445511.png)

这四种修饰符在任意时刻只能出现一种，JavaBean中一般成员属性私有`private`，成员方法公有`public`

### 4.代码块

#### 4.1.分类

代码块就是使用`{}`括起来的代码，分为以下几种类型

- **局部代码块**：在方法内部，**用于提前结束变量的生命周期**，因为变量的生命周期在最近的`{}`中，为什么需要提前结束变量的生命周期呢？为了及时释放内存，提高内存利用率

  ![1662452718272](assets\1662452718272.png)

- **构造代码块**：在类的成员位置，**每次调用构造方法前都会先执行构造代码块**，所以构造代码块用于将多个构造方法的共同代码抽取出来

  ![1662452932411](assets\1662452932411.png)

- **静态代码块**：在类的成员位置，使用`static`修饰，随着类的加载而加载，会**自动触发**，**只执行一次**，用于数据的初始化

#### 4.2.顺序

**代码块的执行过程**是`静态代码块(只执行一次) -> 构造代码块(每次调用构造方法时执行) -> 构造方法`

**类的初始化过程**是`默认初始化 -> 显示值初始化 -> 构造方法初始化`

当**存在继承**关系，则执行过程是`父类初始化 -> 子类初始化`

所以**完整的执行过程**是`父静态代码块 -> 子静态代码块 -> 父构造代码块->父构造方法 -> 构造代码块子->构造方法子`

> 参考课程：[黑马程序员Java零基础视频教程(2022)](https://www.bilibili.com/video/BV17F411T7Ao?p=1&vd_source=8811945bf338927db8b1ca45a8f75a87)





































