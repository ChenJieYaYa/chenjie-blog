# MySQL进阶

## 一、存储引擎

### 1.MySQL体系结构

MySQL服务层共分为以下四层

![1667092552606](assets/1667092552606.png)

### 2.存储引擎是什么？

引擎可理解为发动机，飞机和汽车可以使用同一引擎嘛？当然是不能的，飞机引擎和汽车引擎决定他们的发动方式

**存储引擎就是存储数据、建立索引、更新查询数据等技术的实现方式**，存储引擎是**基于表**的，而不是库，故又可被称为表类型

------

在创建表时通过关键字`ENGINE`指定存储引擎，SQL语句如下

```mysql
create table 表名(
	...
)ENGINE=INNODB;
```

查看当前数据库支持的存储引擎SQL语句是`show engines;`

![1667095259593](assets/1667095259593.png)

### 3.存储引擎特点

#### 3.1.InnoDB

**InnoDB是高可靠和高性能的通用存储引擎**，MySQL5.5后是默认的存储引擎，其特点如下

* DML操作支持**事务**，满足ACID模型
* 支持**外键约束**，保证数据完整性和正确性
* **行级锁**，提高并发访问性能

每张以InnoDB为存储引擎的表都对应一个**表空间文件**`table_name.ibd`，用于**存储表结构、数据和索引**。参数`innodb_file_per_table`用于决定是否共享表空间文件，MySQL8中默认每张表对应一个表空间文件，通过`show variables like 'innodb_file_per_table'`可查询

InnoDB的逻辑存储结构如下

![1667096424113](assets/1667096424113.png)

#### 3.2.MyISAM

MyISAM是MySQL早期的默认存储引擎，其特点如下

* 不支持事务，不支持外键
* 表级锁，不支持行级锁
* 访问速度快

每张以MyISAM为存储引擎的表都涉及三个文件，`xxx.sdi`存储表结构、`xxx.MYD`存储数据、`xxx.MYI`存储索引

#### 3.3.Memory

Memory会将表数据存于内存，由于受到硬件和断电的影响，所以只做临时表或缓存使用，默认`hash`索引，`xxx.sdi`用于存储表结构信息

Memory存于内存所以访问速度比较快，但不能存太大的表，且数据的安全性无法得到保障

### 4.存储引擎选择

存储引擎没有好坏之分，只需在合适的场景选择合适的引擎即可，根据不同引擎的特点适用场景各不相同

| 存储引擎 |                           适用场景                           |
| :------: | :----------------------------------------------------------: |
|  InnoDB  | 对数据完整性要求较高、并发场景下要求数据一致、包含很多更新和删除操作 |
|  MyISAM  | 以插入和查询操作为主、对数据完整性和并发一致性要求不高，但这种场景通常被`MongoDB`替代 |
|  Memory  | 访问速度快，常用于临时表及缓存，但这种场景通常被`Redis`替代  |

## 二、索引

### 1.索引是什么？

数据之外数据库系统还维护着满足特定查找算法的数据结构，**索引就是帮助MySQL高速获取数据的数据结构**

为什么需要索引呢？原来没有索引对`user`表执行`select * from user where age=45;`时会顺序的对比每个`age`是否为45，直到遍历完整张表，这种方式称为**全表扫描**，性能极低！那么有索引呢，以二叉树结构为例请看下图！只需对比三次就找到所需的数据

![1667997486157](assets/1667997486157.png)

### 2.索引优缺点

|       优点       |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
|  **检索效率高**  | 索引是帮助高速获取数据的数据结构，且降低数据库的IO成本(数据库的数据存于磁盘) |
| **排序成本降低** |               索引数据结构都有序，降低CPU消耗                |

|        缺点        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
|  **占用磁盘空间**  | 学习存储引擎可知表结构、数据和索引都存于磁盘(可忽略，磁盘很便宜) |
| **增删改效率降低** | 每次增删改数据的同时维护的索引数据结构也需要相应变化(可忽略，对与正常业务系统增删改很少) |

### 3.索引结构

#### 3.1.概述

通过MySQL体系结构图可知索引在存储引擎层实现，不同的存储引擎有不同的结构，主要包含以下几种

|     索引结构      |                             描述                             |  InnoDB   | MyISAM | Memory |
| :---------------: | :----------------------------------------------------------: | :-------: | :----: | :----: |
|  **B+Tree索引**   |            **最常见的索引**，大部分存储引擎都支持            |   支持    |  支持  |  支持  |
|     Hash索引      | 底层是哈希表，只有**精确匹配索引列的查询才有效，不支持范围查询** |  不支持   | 不支持 |  支持  |
|  R-Tree空间索引   | MyISAM存储引擎的特殊索引结构，主要用于地理空间数据类型，用得较少 |  不支持   |  支持  | 不支持 |
| Full-text全文索引 |                   建立倒排索引快速匹配文档                   | 5.6后支持 |  支持  | 不支持 |

#### 3.2.B+Tree索引

B+Tree是什么？为什么出现？让我们从二叉树开始步步升入

①二叉树指只有两个节点的树，二叉排序树在二叉树的基础上保证`左<根<右`，但**顺序插入时会形成链表**，若**数据量较大还会导致树的层级比较深**，检索速度减慢

![1667999295687](assets/1667999295687.png)

②红黑树是特殊的二叉查找树，根据红黑规则自旋平衡该树，解决顺序插入时形成链表的问题，但红黑树本身也是二叉树，无法解决数据量大层级深的问题

![1667999502403](assets/1667999502403.png)

> ①②中二叉树、二叉查找树、平衡二叉树和红黑树相关知识请跳转至[集合的Set数据结构部分](/Java基础/集合)

③**B树又称为多路平衡查找树，一个节点下可包含多个子节点**，解决二叉树层级深的问题，但B树中叶子节点和非叶子节点都可存放数据，但每页的大小有限，所以导致每页的键值减少，指针也减少，从而只能增加树的高度

![1668000081310](assets/1668000081310.png)

> [数据结构可视化网站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

④**B+树所有的元素都会出现在叶子节点，数据也都存于叶子节点，其他非叶子节点只起到索引的作用，同时叶子节点会形成单向链表**，在B树基础上进一步降低树的层数

![1668000754806](assets/1668000754806.png)

------

MySQL对B+树进行优化，在**原来B+树的基础上增加相邻叶子节点指针**，形成带有顺序指针的B+树，提高区间访问性能

![1668001230874](assets/1668001230874.png)

#### 3.3.Hash索引

首先计算出每行数据的Hash值，然后取出需要建立索引的属性的值通过Hash函数在哈希表中做映射，哈希表中存储的数据为属性值与行哈希值

![1668001544552](assets/1668001544552.png)

注意Hash索引**不支持范围查询**(`between`、`>`、`<`等)；**不可进行排序**；**不发生哈希冲突时检索一次就可**，效率常常比B+树高

#### 3.4.小小面试题

为什么InnoDB使用B+树，而不使用二叉树、B树、Hash索引呢？

* 二叉树存在无序问题
* 二叉排序树存在顺序插入形成单链表问题
* 平衡二叉树存在大量自旋问题
* 红黑树存在随数据量加大层级加深问题
* B树存在数据存于叶子节点和非叶子节点，导致层级层级还是加深问题
* Hash索引不可范围查询且不可排序

### 4.索引分类



### 5.索引语法















[Linux安装MySQL5](/MySQL/Linux安装MySQL5)	|	[Linux安装MySQL8](/MySQL/Linux安装MySQL8)









**建索引**：`alter table 表名 add index 索引名;`或`create index 索引名 on 表名(字段名);`

**建唯一索引**：`create unique index 索引名 on 表名(字段名);`

**删索引**：`alter table 表名 drop index 索引名;`或`drop index 索引名 on 表名;`

## 三、SQL优化

## 四、视图&存储过程&触发器

视图是虚拟的表，与包含的数据表不同，视图只包含使用时动态检索数据的查询，不包含任何列或数据

**视图：**

是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。

**游标：**

是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

**优点：**

1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。

2)用户通过简单的查询可以从复杂查询中得到结果。

3)维护数据的独立性，试图可从多个表检索数据。

4)对于相同的数据可产生不同的视图。

**缺点：**

性能：查询视图时，必须把视图的查询转化

视图
视图的作用，视图可以更改么？
创建视图： create view xxx as xxx

使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据;
视图创建后，可以使用与表相同的方式利用它们；
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。
对于某些视图，例如，未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新









## 五、锁

## 六、InnoDB引擎

## 七、MySQL管理